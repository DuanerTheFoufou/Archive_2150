<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Grand Archive: 2025-2150</title>
    <style>
        :root {
            --bg-dark: #050505;
            --bg-panel: #0f1115;
            --text-primary: #f0f4f8;
            --text-secondary: #94a3b8;
            --accent-cyan: #06b6d4;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-gold: #f59e0b;
            --border: 1px solid rgba(255, 255, 255, 0.08);
            --font-mono: 'Courier New', monospace;
            --font-sans: system-ui, -apple-system, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: var(--font-sans);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- INTRO OVERLAY --- */
        #introOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 1s ease-out;
        }

        .intro-content {
            max-width: 700px;
            padding: 40px;
            animation: fadeIn 2s ease-in;
        }

        .intro-title {
            font-size: 4rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #fff, #94a3b8);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -2px;
            font-weight: 800;
        }

        .intro-subtitle {
            font-family: var(--font-mono);
            color: var(--accent-cyan);
            font-size: 1rem;
            margin-bottom: 30px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .intro-text {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 50px;
            line-height: 1.6;
        }

        .lang-selection {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .lang-btn {
            background: transparent;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
            padding: 10px 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .lang-btn.active,
        .lang-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.2);
        }

        .enter-btn {
            background: var(--text-primary);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
        }

        .enter-btn.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .enter-btn:hover {
            background: var(--accent-cyan);
            box-shadow: 0 0 30px rgba(6, 182, 212, 0.4);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- LAYOUT --- */
        .main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
        }

        /* SIDEBAR (Timeline) */
        .sidebar {
            width: 280px;
            background: var(--bg-panel);
            border-right: var(--border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .timeline-item {
            padding: 15px 20px;
            border-bottom: var(--border);
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
            display: flex;
            flex-direction: column;
        }

        .timeline-item:hover {
            opacity: 0.8;
            background: rgba(255, 255, 255, 0.02);
        }

        .timeline-item.active {
            opacity: 1;
            background: rgba(6, 182, 212, 0.05);
            border-left: 3px solid var(--accent-cyan);
        }

        .t-year {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--accent-cyan);
            margin-bottom: 4px;
        }

        .t-title {
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* CENTER (Narrative) */
        .narrative {
            flex: 1;
            max-width: 500px;
            padding: 50px;
            overflow-y: auto;
            border-right: var(--border);
            background: radial-gradient(circle at top left, #14161f 0%, #0a0b10 100%);
            flex-shrink: 0;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 15px;
            color: white;
            letter-spacing: -1px;
            line-height: 1.1;
        }

        h2 {
            font-size: 0.8rem;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 30px;
            font-family: var(--font-mono);
            opacity: 0.8;
        }

        p {
            line-height: 1.8;
            color: var(--text-secondary);
            margin-bottom: 25px;
            font-size: 1.05rem;
        }

        strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* RIGHT (Simulation) */
        .simulation-area {
            flex: 1.5;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* CONTROLS OVERLAY */
        .controls-overlay {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 17, 21, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 16px;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            transition: opacity 0.3s;
            z-index: 10;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent-cyan);
            cursor: pointer;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* HEADER */
        header {
            height: 60px;
            border-bottom: var(--border);
            display: flex;
            align-items: center;
            padding: 0 25px;
            background: var(--bg-dark);
            justify-content: space-between;
        }

        .archive-status {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--accent-green);
            letter-spacing: 1px;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: 0.2s;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                height: auto;
                /* Allow scrolling */
            }

            /* 1. Simulation on Top */
            .simulation-area {
                order: 1;
                width: 100%;
                height: 40vh;
                /* Fixed height for sim */
                min-height: 300px;
                border-left: none;
                border-bottom: var(--border);
            }

            /* 2. Timeline Strip */
            .sidebar {
                order: 2;
                width: 100%;
                height: 70px;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                border-right: none;
                border-bottom: var(--border);
                padding: 10px;
                white-space: nowrap;
            }

            .timeline-item {
                display: inline-block;
                width: auto;
                min-width: 120px;
                margin-bottom: 0;
                margin-right: 10px;
                padding: 10px;
            }

            /* 3. Narrative Below */
            .narrative {
                order: 3;
                width: 100%;
                height: auto;
                padding: 20px;
                overflow-y: visible;
                /* Let page scroll */
            }

            /* Adjustments */
            header {
                font-size: 0.8rem;
                padding: 10px;
                text-align: center;
            }

            .archive-status {
                display: none;
                /* Hide status on small screens to save space */
            }

            .intro-title {
                font-size: 3rem;
            }

            .controls-overlay {
                width: 95%;
                bottom: 10px;
                padding: 15px;
            }
        }
    </style>
</head>

<body>

    <!-- INTRO OVERLAY -->
    <div id="introOverlay">
        <div class="intro-content">
            <div class="intro-subtitle">System Boot Sequence Initiated</div>
            <div class="intro-title">ARCHIVE 2150</div>
            <div class="intro-text" id="introText">
                In a world of emergent AI, discover the history of the future.<br>
                Become the historian of a society transformed.
            </div>

            <div class="lang-selection">
                <button class="lang-btn active" onclick="selectLang('en', this)">English</button>
                <button class="lang-btn" onclick="selectLang('fr', this)">Français</button>
            </div>

            <button class="enter-btn" id="enterBtn" onclick="startExperience()">ENTER ARCHIVE</button>
        </div>
    </div>

    <header>
        <div style="font-weight:800; letter-spacing: -0.5px;">ARCHIVE_2150 // HISTORICAL RECONSTRUCTION</div>
        <div class="archive-status">● SYSTEM ONLINE</div>
    </header>

    <div class="main-container">
        <!-- 1. TIMELINE -->
        <div class="sidebar" id="sidebar">
            <!-- Injected via JS -->
        </div>

        <!-- 2. NARRATIVE -->
        <div class="narrative" id="narrativeContent">
            <!-- Injected via JS -->
        </div>

        <!-- 3. SIMULATION -->
        <div class="simulation-area">
            <canvas id="simCanvas"></canvas>
            <div class="controls-overlay" id="simControls">
                <!-- Injected via JS -->
            </div>
        </div>
    </div>

    <script>
        /**
         * --- INTERNATIONALIZATION & DATA ---
         */
        const translations = {
            en: {
                title: "ARCHIVE_2150 // HISTORICAL RECONSTRUCTION",
                status: "● SYSTEM ONLINE",
                back: "&larr; Back",
                next: "Next Era &rarr;",
                intro: {
                    subtitle: "System Boot Sequence Initiated",
                    text: "In a world of emergent AI, discover the history of the future.<br>Become the historian of a society transformed.",
                    enter: "ENTER ARCHIVE"
                },
                controls: {
                    compute: "Compute Power",
                    autonomy: "AI Autonomy Level",
                    dexterity: "Robotic Dexterity",
                    solar: "Solar Efficiency",
                    auto: "Automation Integration",
                    pressure: "Corporate Cost Pressure",
                    wealth: "Wealth Concentration",
                    timeline: "Timeline",
                    stimulus: "INJECT $10 TRILLION",
                    ideology: "Ideological Shift",
                    valve: "Dividend Valve Flow",
                    focus: "Focus: Creativity",
                    metric: "Metric:",
                    market: "Market Mode",
                    access: "Access Mode",
                    research: "Research Speed",
                    launch: "INITIATE LAUNCH SEQUENCE"
                }
            },
            fr: {
                title: "ARCHIVE_2150 // RECONSTRUCTION HISTORIQUE",
                status: "● SYSTÈME EN LIGNE",
                back: "&larr; Retour",
                next: "Ère Suivante &rarr;",
                intro: {
                    subtitle: "Séquence de Démarrage Initiée",
                    text: "Dans un monde d'IA émergente, découvrez l'histoire du futur.<br>Devenez l'historien d'une société transformée.",
                    enter: "ENTRER DANS L'ARCHIVE"
                },
                controls: {
                    compute: "Puissance de Calcul",
                    autonomy: "Niveau d'Autonomie IA",
                    dexterity: "Dextérité Robotique",
                    solar: "Efficacité Solaire",
                    auto: "Intégration de l'Automatisation",
                    pressure: "Pression des Coûts",
                    wealth: "Concentration des Richesses",
                    timeline: "Chronologie",
                    stimulus: "INJECTER 10 BILLIONS $",
                    ideology: "Changement Idéologique",
                    valve: "Flux du Dividende",
                    focus: "Focus: Créativité",
                    metric: "Métrique:",
                    market: "Mode Marché",
                    access: "Mode Accès",
                    research: "Vitesse de Recherche",
                    launch: "LANCER LA SÉQUENCE"
                }
            }
        };

        let currentLang = 'en';

        function getChapters(lang) {
            const isEn = lang === 'en';
            return [
                {
                    year: "2025",
                    title: isEn ? "The Spark" : "L'Étincelle",
                    subtitle: isEn ? "Where we stand today" : "Où nous en sommes",
                    text: isEn ?
                        `<p>Welcome, student. You are accessing this archive from the year 2150. We are looking back at the most turbulent century in human history.</p>
                        <p>It starts in <strong>2025</strong>. At this moment, AI was still "Digital." Large Language Models (LLMs) could write code and poetry, but they were trapped in servers. They had no hands.</p>
                        <p>The economy was stable. People worked for wages. Capital (machines) and Labor (humans) were roughly balanced partners. But the spark had been lit. The cost of intelligence was dropping by 10x every year.</p>
                        <p><strong>Simulation:</strong> Observe the neural network. It is growing, but isolated. Adjust the <em>Compute Power</em> to see how the network density increases.</p>` :
                        `<p>Bienvenue, étudiant. Vous accédez à cette archive depuis l'an 2150. Nous regardons en arrière sur le siècle le plus turbulent de l'histoire humaine.</p>
                        <p>Tout commence en <strong>2025</strong>. À ce moment, l'IA était encore "Numérique". Les LLM pouvaient écrire du code et de la poésie, mais ils étaient piégés dans des serveurs. Ils n'avaient pas de mains.</p>
                        <p>L'économie était stable. Les gens travaillaient pour un salaire. Le Capital (machines) et le Travail (humains) étaient des partenaires à peu près équilibrés. Mais l'étincelle avait été allumée.</p>
                        <p><strong>Simulation :</strong> Observez le réseau neuronal. Il grandit, mais reste isolé. Ajustez la <em>Puissance de Calcul</em> pour voir la densité du réseau augmenter.</p>`,
                    simId: "SPARK",
                    controls: `<label>${translations[lang].controls.compute} <span id="val1">Low</span></label><input type="range" min="10" max="100" value="20" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2028-2032",
                    title: isEn ? "The Agentic Era" : "L'Ère Agentique",
                    subtitle: isEn ? "From Chatbots to Workers" : "Des Chatbots aux Travailleurs",
                    text: isEn ?
                        `<p>By roughly 2030, AI stopped being a "chatbot" and became an "Agent."</p>
                        <p>An Agent doesn't just talk; it <em>does</em>. It could browse the web, use software, send emails, and code entire apps without human intervention. This was the first wave of displacement: white-collar digital tasks.</p>
                        <p>Data entry, basic coding, translation, and customer service began to automate. However, the economy held up because new roles (supervisors, prompt engineers) were created.</p>
                        <p><strong>Simulation:</strong> Watch the "Swarm". Agents (Blue) actively hunt for tasks, moving faster and more efficiently than humans (Green).</p>` :
                        `<p>Vers 2030, l'IA a cessé d'être un "chatbot" pour devenir un "Agent".</p>
                        <p>Un Agent ne fait pas que parler ; il <em>agit</em>. Il pouvait naviguer sur le web, utiliser des logiciels et coder des applications entières sans intervention humaine.</p>
                        <p>La saisie de données, le codage de base et le service client ont commencé à s'automatiser. L'économie a tenu bon grâce à la création de nouveaux rôles.</p>
                        <p><strong>Simulation :</strong> Regardez l'essaim. Les agents (bleus) chassent activement les tâches, se déplaçant plus vite et plus efficacement que les humains (verts).</p>`,
                    simId: "AGENTS",
                    controls: `<label>${translations[lang].controls.autonomy} <span id="val1">0%</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2035-2040",
                    title: isEn ? "The Physical Link" : "Le Lien Physique",
                    subtitle: isEn ? "Robotics catches up" : "La robotique rattrape son retard",
                    text: isEn ?
                        `<p>For a long time, we thought blue-collar jobs were safe. "AI can't fix a clear plumbing pipe," we said.</p>
                        <p>We were wrong. By the late 2030s, humanoid robotics solved the battery and motor issues. Combined with the "Brain" of advanced AI, robots could now learn physical tasks by watching videos.</p>
                        <p>This was the turning point. Automation left the screen and entered the factory, the warehouse, and the construction site.</p>
                        <p><strong>Simulation:</strong> The robot arm. Increase <em>Dexterity</em> to see it match human speed and precision.</p>` :
                        `<p>Pendant longtemps, nous pensions que les emplois manuels étaient sûrs. "L'IA ne peut pas réparer un tuyau", disions-nous.</p>
                        <p>Nous avions tort. À la fin des années 2030, la robotique humanoïde a résolu les problèmes de batterie et de moteur. Combinés au "Cerveau" de l'IA avancée, les robots pouvaient apprendre des tâches physiques.</p>
                        <p>C'était le tournant. L'automatisation a quitté l'écran pour entrer dans l'usine et le chantier.</p>
                        <p><strong>Simulation :</strong> Le bras robotique. Augmentez la <em>Dextérité</em> pour le voir égaler la vitesse et la précision humaines.</p>`,
                    simId: "ROBOTICS",
                    controls: `<label>${translations[lang].controls.dexterity} <span id="val1">Clumsy</span></label><input type="range" min="0" max="100" value="10" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2042",
                    title: isEn ? "The Energy Zero" : "Le Zéro Énergétique",
                    subtitle: isEn ? "Infinite Power" : "Énergie Infinie",
                    text: isEn ?
                        `<p>Robots needed energy, and they found a way to make it themselves. Self-replicating solar arrays began to cover the deserts.</p>
                        <p>With AI optimizing the grid and robots manufacturing panels for the cost of raw sand, the price of energy collapsed to near zero.</p>
                        <p>This was the "Energy Zero" event. Suddenly, the cost to run a factory, desalinate water, or smelt steel became negligible. The only limit was raw materials.</p>
                        <p><strong>Simulation:</strong> Solar Bloom. Watch the arrays multiply organically like a living organism, driving energy costs to zero.</p>` :
                        `<p>Les robots avaient besoin d'énergie, et ils ont trouvé un moyen de la produire eux-mêmes. Des panneaux solaires auto-réplicants ont commencé à couvrir les déserts.</p>
                        <p>Avec l'IA optimisant le réseau et les robots fabriquant des panneaux pour le prix du sable, le coût de l'énergie s'est effondré.</p>
                        <p>C'était l'événement "Zéro Énergétique". Soudain, le coût pour faire tourner une usine ou dessaler l'eau est devenu négligeable.</p>
                        <p><strong>Simulation :</strong> Floraison Solaire. Regardez les panneaux se multiplier organiquement comme un organisme vivant, réduisant les coûts énergétiques à zéro.</p>`,
                    simId: "ENERGY",
                    controls: `<label>${translations[lang].controls.solar} <span id="val1">Low</span></label><input type="range" min="0" max="100" value="10" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2045-2050",
                    title: isEn ? "The Golden Twilight" : "Le Crépuscule Doré",
                    subtitle: isEn ? "The Boom before the Bust" : "Le Boom avant le Krach",
                    text: isEn ?
                        `<p>This decade is often misunderstood. It wasn't a depression; it was a <strong>Boom</strong>.</p>
                        <p>With robots working 24/7 for pennies, the cost of goods plummeted. TVs, cars, and houses became cheaper to build. Corporate profits hit all-time highs.</p>
                        <p>Unemployment rose to 15%, but people survived on "Gig" work and cheap prices. We called it the "Golden Twilight" because everything looked shiny, but the sun was setting on the wage-labor system.</p>
                        <p><strong>Simulation:</strong> Observe the "GDP" (Yellow Line) vs "Median Wage" (Green Line). Increase automation to see GDP soar while wages stagnate.</p>` :
                        `<p>Cette décennie est souvent mal comprise. Ce n'était pas une dépression ; c'était un <strong>Boom</strong>.</p>
                        <p>Avec des robots travaillant 24/7 pour des centimes, le coût des biens a chuté. Les profits des entreprises ont atteint des sommets.</p>
                        <p>Le chômage a augmenté, mais les gens survivaient grâce à l'économie des "petits boulots". Nous l'avons appelé le "Crépuscule Doré".</p>
                        <p><strong>Simulation :</strong> Observez le "PIB" (Ligne Jaune) vs "Salaire Médian" (Ligne Verte). Augmentez l'automatisation pour voir le PIB monter en flèche tandis que les salaires stagnent.</p>`,
                    simId: "BOOM",
                    controls: `<label>${translations[lang].controls.auto} <span id="val1">Low</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2050-2055",
                    title: isEn ? "The Squeeze" : "L'Étau",
                    subtitle: isEn ? "The math breaks down" : "Les mathématiques s'effondrent",
                    text: isEn ?
                        `<p>By 2050, the trend became undeniable. Human labor was no longer competitive. Why hire a human for $20/hour when a bot does it for $0.05/hour?</p>
                        <p>Wages began to actively shrink. People took 2nd and 3rd jobs to compete. The "Gig Economy" became the "Desperation Economy."</p>
                        <p>Crucially, debt began to default. People couldn't pay mortgages. The cracks in the foundation were visible to everyone.</p>
                        <p><strong>Simulation:</strong> The Worker Pool. As you increase <em>Cost Pressure</em>, workers turn red (insolvent) and drop out of the economy.</p>` :
                        `<p>En 2050, la tendance était indéniable. Le travail humain n'était plus compétitif. Pourquoi embaucher un humain à 20$/h quand un robot le fait pour 0,05$/h ?</p>
                        <p>Les salaires ont commencé à baisser. L'économie des petits boulots est devenue l'économie du désespoir.</p>
                        <p>Les dettes ont commencé à faire défaut. Les fissures dans la fondation étaient visibles pour tous.</p>
                        <p><strong>Simulation :</strong> Le bassin de travailleurs. En augmentant la <em>Pression des Coûts</em>, les travailleurs deviennent rouges (insolvables) et sortent de l'économie.</p>`,
                    simId: "SQUEEZE",
                    controls: `<label>${translations[lang].controls.pressure} <span id="val1">Normal</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2058",
                    title: isEn ? "The Velocity Freeze" : "Le Gel de la Vélocité",
                    subtitle: isEn ? "Money stops moving" : "L'argent arrête de circuler",
                    text: isEn ?
                        `<p>An economy requires the <strong>Velocity of Money</strong>. I pay you, you pay the grocer, the grocer pays the farmer.</p>
                        <p>In 2058, this loop slowed to a crawl. Corporations had all the money, but no one to sell to. They had automated the customer out of existence.</p>
                        <p>Deflation set in. Prices dropped, but no one bought anything because they were waiting for prices to drop further, or simply had zero income.</p>
                        <p><strong>Simulation:</strong> Velocity visualization. Watch the particles (transactions) slow down as Wealth Concentration hits 99%.</p>` :
                        `<p>Une économie nécessite la <strong>Vélocité de l'Argent</strong>. Je vous paie, vous payez l'épicier, l'épicier paie le fermier.</p>
                        <p>En 2058, cette boucle a ralenti. Les entreprises avaient tout l'argent, mais personne à qui vendre. Elles avaient automatisé le client jusqu'à l'inexistence.</p>
                        <p><strong>Simulation :</strong> Visualisation de la vélocité. Regardez les particules (transactions) ralentir alors que la concentration des richesses atteint 99%.</p>`,
                    simId: "FREEZE",
                    controls: `<label>${translations[lang].controls.wealth} <span id="val1">Low</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2060",
                    title: isEn ? "THE BIG CRASH" : "LE GRAND KRACH",
                    subtitle: isEn ? "The Silent Depression" : "La Dépression Silencieuse",
                    text: isEn ?
                        `<p><strong>This is the pivot point of history.</strong></p>
                        <p>In 2060, the global supply chain halted. Warehouses were full of goods. Robots stood ready to build more. But the transaction layer ceased to exist. Unemployment hit 60%.</p>
                        <p>It wasn't a stock market crash; it was a <strong>Demand Crash</strong>. The engine of capitalism (Labor for Income for Consumption) seized up completely.</p>
                        <p><strong>Simulation:</strong> The Economy Graph. Watch Productivity (Blue) go vertical while Employment (Green) crashes. When unemployment hits 50%, the system breaks.</p>` :
                        `<p><strong>C'est le point de bascule de l'histoire.</strong></p>
                        <p>En 2060, la chaîne d'approvisionnement mondiale s'est arrêtée. Les entrepôts étaient pleins. Mais la couche transactionnelle a cessé d'exister. Le chômage a atteint 60%.</p>
                        <p>Ce n'était pas un krach boursier ; c'était un <strong>Krach de la Demande</strong>. Le moteur du capitalisme s'est grippé.</p>
                        <p><strong>Simulation :</strong> Le graphique de l'économie. Regardez la productivité (bleu) devenir verticale tandis que l'emploi (vert) s'effondre. Quand le chômage atteint 50%, le système casse.</p>`,
                    simId: "CRASH",
                    controls: `<label>${translations[lang].controls.timeline} <span id="val1">2040</span></label><input type="range" min="2040" max="2070" value="2040" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2061",
                    title: isEn ? "The Failed Stimulus" : "L'Échec du Stimulus",
                    subtitle: isEn ? "Why printing money didn't work" : "Pourquoi imprimer de l'argent n'a pas marché",
                    text: isEn ?
                        `<p>Governments panicked. They tried the old playbook: Print money and lend it to people (Stimulus/Debt).</p>
                        <p>It failed immediately. Why? Because you can only lend money to people who have jobs to pay it back. With no jobs, the credit was worthless.</p>
                        <p>The money was printed, given out, spent once on food, and immediately vacuumed back up by the automated corporations, sitting in their accounts doing nothing. The loop was broken.</p>
                        <p><strong>Simulation:</strong> Attempt to inject liquidity. Watch the water (money) pour in, but drain out instantly because there is no "Labor Floor" to hold it.</p>` :
                        `<p>Les gouvernements ont paniqué. Ils ont essayé la vieille méthode : Imprimer de l'argent et le prêter aux gens.</p>
                        <p>Cela a échoué immédiatement. On ne peut prêter de l'argent qu'à ceux qui ont un emploi pour le rembourser. Sans emploi, le crédit ne valait rien.</p>
                        <p><strong>Simulation :</strong> Tentative d'injection de liquidités. Regardez l'eau (argent) couler, mais se vider instantanément car il n'y a pas de "sol de travail" pour la retenir.</p>`,
                    simId: "STIMULUS",
                    controls: `<button class="nav-btn" style="width:100%; background:#ef4444" onclick="triggerStimulus()">${translations[lang].controls.stimulus}</button>`
                },
                {
                    year: "2062-2064",
                    title: isEn ? "The Realization" : "La Réalisation",
                    subtitle: isEn ? "No Choice Left" : "Plus le choix",
                    text: isEn ?
                        `<p>Society faced a choice: Starve amidst abundance, or change the operating system.</p>
                        <p>Economists realized that automation had turned labor into a legacy feature. The realization was simple: <strong>Money must be decoupled from Labor.</strong></p>
                        <p>If robots make the resources, we just need to distribute the tickets.</p>
                        <p><strong>Simulation:</strong> Circuit Rewiring. Connect the "Production" node directly to the "Consumption" node, bypassing the broken "Labor" switch.</p>` :
                        `<p>La société faisait face à un choix : Mourir de faim au milieu de l'abondance, ou changer le système d'exploitation.</p>
                        <p>Les économistes ont réalisé que l'automatisation avait rendu le travail obsolète. <strong>L'argent devait être découplé du Travail.</strong></p>
                        <p><strong>Simulation :</strong> Recâblage du circuit. Connectez le nœud "Production" directement au nœud "Consommation", en contournant l'interrupteur cassé du "Travail".</p>`,
                    simId: "SCALE",
                    controls: `<label>${translations[lang].controls.ideology} <span id="val1">Traditional</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2065",
                    title: isEn ? "The Dividend Compact" : "Le Pacte du Dividende",
                    subtitle: isEn ? "Dividend Socialism" : "Socialisme de Dividende",
                    text: isEn ?
                        `<p>The treaty was signed. The "Automation Tax" was implemented. Every robot hour worked generated a micro-tax.</p>
                        <p>This revenue was not filtered through bureaucracy; it was distributed instantly to every citizen as a <strong>Universal Dividend</strong>.</p>
                        <p>This wasn't charity. It was the fuel injection required to make the machine run. The moment the dividend went live, the warehouses opened, goods moved, and the economy restarted.</p>
                        <p><strong>Simulation:</strong> The Flow. Open the valve to let the "Tax Particles" flow from the factories to the people, restarting the cycle.</p>` :
                        `<p>Le traité a été signé. La "Taxe d'Automatisation" a été mise en œuvre. Chaque heure de robot générait une micro-taxe.</p>
                        <p>Ce revenu était distribué instantanément à chaque citoyen sous forme de <strong>Dividende Universel</strong>.</p>
                        <p>Ce n'était pas de la charité. C'était l'injection de carburant nécessaire pour faire tourner la machine.</p>
                        <p><strong>Simulation :</strong> Le Flux. Ouvrez la vanne pour laisser les "Particules de Taxe" couler des usines vers les gens, redémarrant le cycle.</p>`,
                    simId: "DIVIDEND",
                    controls: `<label>${translations[lang].controls.valve} <span id="val1">Closed</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2070",
                    title: isEn ? "The Purpose Crisis" : "La Crise du Sens",
                    subtitle: isEn ? "What do we do now?" : "Que fait-on maintenant ?",
                    text: isEn ?
                        `<p>Survival was solved. But a new problem emerged: Meaning.</p>
                        <p>For 5,000 years, humans defined themselves by their jobs. "I am a baker." "I am a coder." Without work, depression rates spiked.</p>
                        <p>We had to culturally reinvent ourselves. We moved from a "Production Society" to an "Exploration Society." Art, philosophy, sport, and community became the new metrics of success.</p>
                        <p><strong>Simulation:</strong> The Tree of Life. Allocate time to "Community", "Art", and "Sport" to see the tree grow. Neglect them, and it withers.</p>` :
                        `<p>La survie était résolue. Mais un nouveau problème a émergé : Le Sens.</p>
                        <p>Pendant 5000 ans, les humains se définissaient par leur travail. Sans travail, la dépression a explosé.</p>
                        <p>Nous avons dû nous réinventer culturellement. L'art, la philosophie, le sport et la communauté sont devenus les nouveaux critères de succès.</p>
                        <p><strong>Simulation :</strong> L'Arbre de Vie. Allouez du temps à la "Communauté", à "l'Art" et au "Sport" pour voir l'arbre grandir. Négligez-les, et il se flétrit.</p>`,
                    simId: "PURPOSE",
                    controls: `
                        <label>${translations[lang].controls.focus} <span id="val1">0%</span></label>
                        <input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">
                        <button class="nav-btn" style="margin-top:10px; width:100%; font-size:0.8rem" onclick="simState.seed = Date.now()">↻ New Tree Variant</button>
                    `
                },
                {
                    year: "2080",
                    title: isEn ? "The Legitimacy Economy" : "L'Économie de la Légitimité",
                    subtitle: isEn ? "Status without Wealth" : "Statut sans Richesse",
                    text: isEn ?
                        `<p>In 2080, the scarcity wasn't money—it was <strong>Trust</strong>.</p>
                        <p>With AI generating infinite content, reality became a battlefield. Narratives acted like viruses, competing for host minds in a "Darwinian War of Ideas."</p>
                        <p>To maintain Legitimacy, leaders had to balance <strong>Reach</strong> (how far the message spreads) with <strong>Stickiness</strong> (how deeply it convinces).</p>
                        <p><strong>Simulation:</strong> The Narrative War. You are the <span style="color:#06b6d4">Blue Narrative</span>. Defeat the <span style="color:#ef4444">Red Misinformation</span>. Adjust your viral parameters to win the crowd (Grey).</p>` :
                        `<p>En 2080, la rareté n'était pas l'argent, mais la <strong>Confiance</strong>.</p>
                        <p>Les récits agissaient comme des virus, s'affrontant pour les esprits dans une "Guerre Darwinienne des Idées".</p>
                        <p><strong>Simulation :</strong> La Guerre Narrative. Vous êtes le <span style="color:#06b6d4">Récit Bleu</span>. Vainquez la <span style="color:#ef4444">Désinformation Rouge</span>. Ajustez vos paramètres viraux pour gagner la foule.</p>`,
                    simId: "STATUS",
                    controls: `
                        <label>${translations[lang].controls.reach || "Viral Reach"} <span id="val1">Medium</span></label>
                        <input type="range" min="10" max="100" value="50" oninput="updateParam('p1', this.value)">
                        
                        <label>${translations[lang].controls.stickiness || "Stickiness"} <span id="val2">Medium</span></label>
                        <input type="range" min="10" max="100" value="50" oninput="updateParam('p2', this.value)">
                        
                        <button class="nav-btn" style="margin-top:10px; width:100%; font-size:0.8rem" onclick="resetStatusSim()">↻ Deploy New Narrative</button>
                    `
                },
                {
                    year: "2090",
                    title: isEn ? "Allocation of the Scarce" : "Allocation de la Rareté",
                    subtitle: isEn ? "Land and Reality" : "Terre et Réalité",
                    text: isEn ?
                        `<p>Robots could print goods, but they couldn't print Land. Who gets the beach house?</p>
                        <p>We moved to "Access Rights." Instead of buying land forever, you gained time-limited leases based on lotteries and merit.</p>
                        <p>This prevented a permanent aristocracy. It ensured that the "Prime Reality" circulated among the population rather than being hoarded.</p>
                        <p><strong>Simulation:</strong> The Zone Lottery. You are the Green Dot. Watch your location shift between Zones A (Beach), B (City), C (Forest), and D (Suburbs) over time.</p>` :
                        `<p>Les robots pouvaient imprimer des biens, mais pas la Terre. Qui obtient la maison sur la plage ?</p>
                        <p>Nous sommes passés aux "Droits d'Accès". Au lieu d'acheter la terre pour toujours, vous obteniez des baux limités dans le temps.</p>
                        <p><strong>Simulation :</strong> La Loterie de Zone. Vous êtes le point vert. Regardez votre emplacement changer entre les zones A (Plage), B (Ville), C (Forêt) et D (Banlieue) au fil du temps.</p>`,
                    simId: "LAND",
                    controls: `<button class="nav-btn" onclick="updateParam('p1', 0)">${translations[lang].controls.market}</button> <button class="nav-btn" onclick="updateParam('p1', 1)">${translations[lang].controls.access}</button>`
                },
                {
                    year: "2100",
                    title: isEn ? "The Guardrails" : "Les Garde-fous",
                    subtitle: isEn ? "Containing the Infinite" : "Contenir l'Infini",
                    text: isEn ?
                        `<p>AI Intelligence was now billions of times greater than human intelligence. The risk wasn't economic anymore; it was existential.</p>
                        <p>Society built the "Great Guardrails." We used AI to police AI. Research was accelerated, but automated safety loops checked every discovery before implementation.</p>
                        <p>We essentially built a nuclear reactor for intelligence, carefully managed to prevent a meltdown.</p>
                        <p><strong>Simulation:</strong> The Reactor. Increase Research Speed, but keep Risk below the critical threshold using Safety Checks.</p>` :
                        `<p>L'intelligence de l'IA était maintenant des milliards de fois supérieure à l'intelligence humaine. Le risque était existentiel.</p>
                        <p>La société a construit les "Grands Garde-fous". Nous avons utilisé l'IA pour surveiller l'IA.</p>
                        <p><strong>Simulation :</strong> Le Réacteur. Augmentez la vitesse de recherche, mais gardez le risque sous le seuil critique en utilisant les contrôles de sécurité.</p>`,
                    simId: "GUARDRAILS",
                    controls: `<label>${translations[lang].controls.research} <span id="val1">Safe</span></label><input type="range" min="0" max="100" value="20" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2150",
                    title: isEn ? "The Horizon" : "L'Horizon",
                    subtitle: isEn ? "To the Stars" : "Vers les Étoiles",
                    text: isEn ?
                        `<p>Here we are, in 2150.</p>
                        <p>We have decoupled survival from labor. We have stabilized the social structure. We have unlimited intelligence and energy.</p>
                        <p>The only frontier left is outwards. The surplus energy of humanity is now directed at Mars, Europa, and Alpha Centauri. We are no longer laborers; we are explorers.</p>
                        <p><strong>Simulation:</strong> The Departure. Initiate the launch sequence to witness humanity's next step.</p>` :
                        `<p>Nous y sommes, en 2150.</p>
                        <p>Nous avons découplé la survie du travail. Nous avons une intelligence et une énergie illimitées.</p>
                        <p>La seule frontière restante est vers l'extérieur. Nous ne sommes plus des travailleurs ; nous sommes des explorateurs.</p>
                        <p><strong>Simulation :</strong> Le Départ. Lancez la séquence de lancement pour assister à la prochaine étape de l'humanité.</p>`,
                    simId: "SPACE",
                    controls: `<button class="nav-btn" style="width:100%; background:var(--accent-cyan); padding: 15px; font-weight:bold; letter-spacing:2px;" onclick="triggerLaunch()">${translations[lang].controls.launch}</button>`
                }
            ];
        }

        /**
         * --- APP STATE & INIT ---
         */
        let chapters = [];
        let currentChapterIdx = 0;
        let simParams = { p1: 0, p2: 0 };
        let canvas, ctx;
        let animationFrame;
        let simState = {};

        function selectLang(lang, btn) {
            currentLang = lang;
            document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');

            // Update Intro Text
            const t = translations[lang].intro;
            document.querySelector('.intro-subtitle').innerText = t.subtitle;
            document.querySelector('#introText').innerHTML = t.text;
            document.querySelector('#enterBtn').innerText = t.enter;

            // Show Enter Button
            document.querySelector('#enterBtn').classList.add('visible');
        }

        function startExperience() {
            document.getElementById('introOverlay').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('introOverlay').style.display = 'none';
                init();
            }, 1000);
        }

        // Canvas Helpers
        function resizeCanvas() {
            if (!canvas) return;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        function init() {
            canvas = document.getElementById('simCanvas');
            ctx = canvas.getContext('2d');

            // Load Data
            chapters = getChapters(currentLang);

            // Populate Sidebar
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = ''; // Clear existing
            chapters.forEach((chap, i) => {
                const div = document.createElement('div');
                div.className = `timeline-item ${i === 0 ? 'active' : ''}`;
                div.innerHTML = `<div class="t-year">${chap.year}</div><div class="t-title">${chap.title}</div>`;
                div.onclick = () => loadChapter(i);
                sidebar.appendChild(div);
            });

            window.addEventListener('resize', resizeCanvas);
            loadChapter(0);
        }

        /**
         * --- CORE LOGIC ---
         */
        function loadChapter(index) {
            currentChapterIdx = index;
            simParams = { p1: 0, p2: 0 }; // Reset params
            simState = {}; // Reset sim state for new chapter

            // UI Updates
            const chap = chapters[index];
            const sidebarItems = document.querySelectorAll('.timeline-item');
            sidebarItems.forEach((item, i) => {
                item.className = `timeline-item ${i === index ? 'active' : ''}`;
                if (i === index) item.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });

            // Narrative Update
            const narrative = document.getElementById('narrativeContent');
            narrative.innerHTML = `
                <h2>${chap.year} // ${chap.subtitle}</h2>
                <h1>${chap.title}</h1>
                ${chap.text}
                <div style="margin-top:40px; display:flex; gap:10px;">
                    <button class="nav-btn" onclick="prev()" ${index === 0 ? 'disabled' : ''}>${translations[currentLang].back}</button>
                    <button class="nav-btn" onclick="next()" ${index === chapters.length - 1 ? 'disabled' : ''}>${translations[currentLang].next}</button>
                </div>
            `;

            // Controls Update
            const controls = document.getElementById('simControls');
            controls.innerHTML = chap.controls;

            // Initialize default params from controls if present
            const inputs = controls.querySelectorAll('input');
            inputs.forEach(input => {
                if (input.oninput) {
                    // Extract param name from oninput string (hacky but works for this structure)
                    // oninput="updateParam('p1', this.value)"
                    const match = input.getAttribute('oninput').match(/'(p\d)'/);
                    if (match) {
                        simParams[match[1]] = parseFloat(input.value);
                        updateParam(match[1], input.value);
                    }
                }
            });

            // Start Animation Loop
            if (animationFrame) cancelAnimationFrame(animationFrame);
            resizeCanvas();
            renderLoop();
        }

        function updateParam(key, value) {
            simParams[key] = parseFloat(value);
            const labelSpan = document.getElementById(key === 'p1' ? 'val1' : 'val2');
            if (labelSpan) {
                const id = chapters[currentChapterIdx].simId;
                if (id === "CRASH") labelSpan.innerText = value;
                else if (id === "LAND" || id === "STATUS") labelSpan.innerText = ""; // No text update needed
                else if (id === "SPACE") labelSpan.innerText = value + (key === 'p2' ? "°" : "%");
                else labelSpan.innerText = value + (id === "GUARDRAILS" ? "" : "%");
            }
        }

        function next() { if (currentChapterIdx < chapters.length - 1) loadChapter(currentChapterIdx + 1); }
        function prev() { if (currentChapterIdx > 0) loadChapter(currentChapterIdx - 1); }

        /**
         * --- VISUALIZATION ENGINE ---
         */
        function renderLoop() {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            const id = chapters[currentChapterIdx].simId;
            const time = Date.now() * 0.001;

            switch (id) {
                case "SPARK": renderSpark(w, h, time); break;
                case "AGENTS": renderAgents(w, h, time); break;
                case "ROBOTICS": renderRobotics(w, h, time); break;
                case "ENERGY": renderEnergy(w, h, time); break;
                case "BOOM": renderBoom(w, h, time); break;
                case "SQUEEZE": renderSqueeze(w, h, time); break;
                case "FREEZE": renderFreeze(w, h, time); break;
                case "CRASH": renderCrash(w, h, time); break;
                case "STIMULUS": renderStimulus(w, h, time); break;
                case "SCALE": renderScale(w, h, time); break;
                case "DIVIDEND": renderDividend(w, h, time); break;
                case "PURPOSE": renderPurpose(w, h, time); break;
                case "STATUS": renderStatus(w, h, time); break;
                case "LAND": renderLand(w, h, time); break;
                case "GUARDRAILS": renderGuardrails(w, h, time); break;
                case "SPACE": renderSpace(w, h, time); break;
            }

            animationFrame = requestAnimationFrame(renderLoop);
        }

        // --- SIMULATIONS ---

        function renderSpark(w, h, t) {
            const density = simParams.p1; // 0 to 100
            const nodeCount = Math.floor(20 + (density / 100) * 80); // 20 to 100 nodes
            const connectDist = 150;

            // Initialize Pool
            if (!simState.nodes || simState.nodes.length !== 100) {
                simState.nodes = Array.from({ length: 100 }, () => ({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 0.8,
                    vy: (Math.random() - 0.5) * 0.8,
                    size: 1.5 + Math.random() * 2,
                    phase: Math.random() * Math.PI * 2
                }));
                simState.pulses = [];
            }

            // Update Nodes
            simState.nodes.forEach(n => {
                n.x += n.vx;
                n.y += n.vy;

                // Wrap
                if (n.x < -50) n.x = w + 50;
                if (n.x > w + 50) n.x = -50;
                if (n.y < -50) n.y = h + 50;
                if (n.y > h + 50) n.y = -50;

                // Pulse Size
                n.currentSize = n.size + Math.sin(t * 2 + n.phase) * 0.5;
            });

            // Draw Connections & Pulses
            ctx.lineWidth = 1.5;
            for (let i = 0; i < nodeCount; i++) {
                const n1 = simState.nodes[i];
                for (let j = i + 1; j < nodeCount; j++) {
                    const n2 = simState.nodes[j];
                    const dx = n1.x - n2.x;
                    const dy = n1.y - n2.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < connectDist) {
                        // Line
                        const alpha = (1 - dist / connectDist);
                        ctx.strokeStyle = `rgba(6, 182, 212, ${alpha * 0.5})`;
                        ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y); ctx.stroke();

                        // Spawn Pulse
                        if (Math.random() < 0.0005 * density) {
                            simState.pulses.push({
                                from: n1,
                                to: n2,
                                p: 0,
                                speed: 0.02 + Math.random() * 0.03,
                                life: 1
                            });
                        }
                    }
                }
            }

            // Draw Pulses
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 6;
            simState.pulses.forEach((p, i) => {
                p.p += p.speed;
                if (p.p >= 1) { p.life = 0; return; }

                const x = p.from.x + (p.to.x - p.from.x) * p.p;
                const y = p.from.y + (p.to.y - p.from.y) * p.p;

                ctx.globalAlpha = p.life;
                ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            });
            simState.pulses = simState.pulses.filter(p => p.life > 0);
            ctx.shadowBlur = 0;

            // Draw Nodes
            for (let i = 0; i < nodeCount; i++) {
                const n = simState.nodes[i];
                ctx.fillStyle = '#06b6d4';
                ctx.shadowColor = '#06b6d4';
                ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.arc(n.x, n.y, n.currentSize, 0, Math.PI * 2); ctx.fill();
            }
            ctx.shadowBlur = 0;
        }

        function renderAgents(w, h, t) {
            const aiLevel = simParams.p1;
            const numAgents = Math.floor(aiLevel / 1.5);
            const numHumans = 40;

            if (!simState.agents) {
                simState.agents = [];
                // Humans
                for (let i = 0; i < numHumans; i++) {
                    simState.agents.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() - 0.5), vy: (Math.random() - 0.5), type: 'human' });
                }
                // AI (Pool)
                for (let i = 0; i < 100; i++) {
                    simState.agents.push({ x: Math.random() * w, y: Math.random() * h, vx: 0, vy: 0, type: 'ai', active: false });
                }
            }

            // Activate AI based on slider
            simState.agents.forEach((a, i) => {
                if (a.type === 'ai') a.active = i < (numHumans + numAgents);
            });

            // Tasks
            if (!simState.tasks) simState.tasks = [];
            if (Math.random() < 0.05) simState.tasks.push({ x: Math.random() * w, y: Math.random() * h, life: 150 });

            // Boids / Swarm Logic
            simState.agents.forEach(a => {
                if (a.type === 'ai' && !a.active) return;

                // Physics
                a.x += a.vx; a.y += a.vy;
                if (a.x < 0 || a.x > w) a.vx *= -1;
                if (a.y < 0 || a.y > h) a.vy *= -1;

                // Behavior
                if (a.type === 'ai') {
                    // Seek Task
                    if (simState.tasks.length > 0) {
                        let closest = null;
                        let minDist = Infinity;
                        simState.tasks.forEach(task => {
                            const d = (task.x - a.x) ** 2 + (task.y - a.y) ** 2;
                            if (d < minDist) { minDist = d; closest = task; }
                        });

                        if (closest) {
                            const angle = Math.atan2(closest.y - a.y, closest.x - a.x);
                            a.vx += Math.cos(angle) * 0.5;
                            a.vy += Math.sin(angle) * 0.5;
                        }
                    }
                    // Friction
                    a.vx *= 0.95; a.vy *= 0.95;

                    ctx.fillStyle = '#06b6d4';
                    ctx.beginPath();
                    ctx.moveTo(a.x + a.vx * 2, a.y + a.vy * 2);
                    ctx.lineTo(a.x - 5, a.y - 5);
                    ctx.lineTo(a.x - 5, a.y + 5);
                    ctx.fill();
                } else {
                    // Human - Browninan
                    a.vx += (Math.random() - 0.5) * 0.2;
                    a.vy += (Math.random() - 0.5) * 0.2;
                    a.vx = Math.max(-2, Math.min(2, a.vx));
                    a.vy = Math.max(-2, Math.min(2, a.vy));

                    ctx.fillStyle = '#10b981';
                    ctx.beginPath(); ctx.arc(a.x, a.y, 4, 0, Math.PI * 2); ctx.fill();
                }
            });

            // Tasks
            simState.tasks.forEach((task, i) => {
                task.life--;
                ctx.strokeStyle = `rgba(255, 255, 255, ${task.life / 150})`;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(task.x, task.y, 8, 0, Math.PI * 2); ctx.stroke();

                // Collision
                simState.agents.forEach(a => {
                    if (a.type === 'ai' && a.active) {
                        if ((a.x - task.x) ** 2 + (a.y - task.y) ** 2 < 400) {
                            task.life = 0;
                            // Particle burst
                            ctx.fillStyle = '#fff';
                            ctx.beginPath(); ctx.arc(task.x, task.y, 15, 0, Math.PI * 2); ctx.fill();
                        }
                    }
                });
            });
            simState.tasks = simState.tasks.filter(t => t.life > 0);
        }

        function renderRobotics(w, h, t) {
            const precision = simParams.p1; // 0 to 100
            const cx = w / 2;
            const cy = h / 2 + 100; // Moved up significantly

            // Initialize State
            if (!simState.robot) {
                simState.robot = {
                    state: 'IDLE', // IDLE, MOVE_TO_PICK, GRAB, MOVE_TO_DROP, DROP
                    target: { x: cx, y: cy - 200 },
                    current: { x: cx, y: cy - 200 },
                    heldBall: null,
                    timer: 0,
                    balls: [], // Balls in the air/bowls
                    score: 0
                };
                // Pre-fill source bowl
                for (let i = 0; i < 5; i++) {
                    simState.robot.balls.push({
                        x: cx - 150 + (Math.random() - 0.5) * 40,
                        y: cy - 20 - Math.random() * 30,
                        vx: 0, vy: 0,
                        state: 'SOURCE' // SOURCE, HELD, DROPPED, DEST
                    });
                }
            }

            const robot = simState.robot;
            const speed = 0.05 + (precision / 100) * 0.15; // Speed based on precision
            const jitterAmt = Math.max(0, (100 - precision) * 0.8); // More jitter

            // Bowl Positions
            const sourcePos = { x: cx - 150, y: cy - 50 };
            const destPos = { x: cx + 150, y: cy - 50 };

            // --- LOGIC ---

            // State Machine
            switch (robot.state) {
                case 'IDLE':
                    robot.state = 'MOVE_TO_PICK';
                    // Find a ball in source
                    const targetBall = robot.balls.find(b => b.state === 'SOURCE');
                    if (targetBall) {
                        robot.target = { x: targetBall.x, y: targetBall.y - 10 };
                    } else {
                        // Spawn new ball if empty
                        robot.balls.push({ x: sourcePos.x, y: sourcePos.y - 100, vx: 0, vy: 0, state: 'SOURCE' });
                        robot.state = 'IDLE'; // Wait for it to fall
                    }
                    break;

                case 'MOVE_TO_PICK':
                    if (dist(robot.current, robot.target) < 15) {
                        robot.state = 'GRAB';
                        robot.timer = 0;
                    }
                    break;

                case 'GRAB':
                    robot.timer++;
                    if (robot.timer > 10) {
                        // Grab closest ball
                        const ball = robot.balls.find(b => b.state === 'SOURCE' && dist(b, robot.current) < 40);

                        // Failure chance: Miss the grab
                        const fumbleChance = (100 - precision) * 0.005; // Up to 50% chance to miss at 0 precision

                        if (ball && Math.random() > fumbleChance) {
                            ball.state = 'HELD';
                            robot.heldBall = ball;
                            robot.state = 'MOVE_TO_DROP';
                            robot.target = { x: destPos.x, y: destPos.y - 100 };
                        } else {
                            // Missed or fumbled
                            robot.state = 'IDLE';
                            // If we missed but there was a ball, maybe knock it
                            if (ball) {
                                ball.vx = (Math.random() - 0.5) * 5;
                                ball.vy = -2;
                            }
                        }
                    }
                    break;

                case 'MOVE_TO_DROP':
                    if (dist(robot.current, robot.target) < 15) {
                        robot.state = 'DROP';
                        robot.timer = 0;
                    }
                    // Chance to drop mid-air (Higher failure rate)
                    // At 0 precision, ~2% chance per frame to drop
                    if (robot.heldBall && Math.random() < (100 - precision) * 0.002) {
                        robot.heldBall.state = 'DROPPED';
                        robot.heldBall.vx = (Math.random() - 0.5) * 5;
                        robot.heldBall.vy = -2;
                        robot.heldBall = null;
                        robot.state = 'IDLE'; // Reset
                    }
                    break;

                case 'DROP':
                    robot.timer++;
                    if (robot.timer > 10) {
                        if (robot.heldBall) {
                            robot.heldBall.state = 'DEST';
                            robot.heldBall.vx = (Math.random() - 0.5) * 2;
                            robot.heldBall.vy = 2;
                            robot.heldBall = null;
                            robot.score++;
                        }
                        robot.state = 'IDLE';
                    }
                    break;
            }

            // Move Arm towards Target (Smooth Lerp)
            // Add jitter to target
            const noisyTarget = {
                x: robot.target.x + (Math.random() - 0.5) * jitterAmt,
                y: robot.target.y + (Math.random() - 0.5) * jitterAmt
            };

            robot.current.x += (noisyTarget.x - robot.current.x) * speed;
            robot.current.y += (noisyTarget.y - robot.current.y) * speed;

            // --- PHYSICS (Balls) ---
            robot.balls.forEach(b => {
                if (b.state === 'HELD') {
                    b.x = robot.current.x;
                    b.y = robot.current.y + 10;
                    b.vx = 0; b.vy = 0;
                } else {
                    // Gravity
                    b.vy += 0.5;
                    b.x += b.vx;
                    b.y += b.vy;
                    b.vx *= 0.95; // Air resistance

                    // Floor / Bowl Collisions
                    // Source Bowl
                    if (b.x > sourcePos.x - 40 && b.x < sourcePos.x + 40 && b.y > sourcePos.y) {
                        b.y = sourcePos.y;
                        b.vy *= -0.5;
                        b.vx *= 0.8;
                        // Keep in bowl
                        if (b.x < sourcePos.x - 30) b.vx += 1;
                        if (b.x > sourcePos.x + 30) b.vx -= 1;
                    }
                    // Dest Bowl
                    if (b.x > destPos.x - 40 && b.x < destPos.x + 40 && b.y > destPos.y) {
                        b.y = destPos.y;
                        b.vy *= -0.5;
                        b.vx *= 0.8;
                        if (b.x < destPos.x - 30) b.vx += 1;
                        if (b.x > destPos.x + 30) b.vx -= 1;
                    }
                    // Floor
                    if (b.y > h - 20) {
                        b.y = h - 20;
                        b.vy *= -0.6;
                        b.vx *= 0.8;
                    }
                }
            });

            // Cleanup fallen balls
            if (robot.balls.length > 15) robot.balls.shift();


            // --- RENDER ---

            // Draw Bowls
            ctx.fillStyle = '#333';
            // Source
            ctx.beginPath(); ctx.arc(sourcePos.x, sourcePos.y, 40, 0, Math.PI, false); ctx.fill();
            // Dest
            ctx.beginPath(); ctx.arc(destPos.x, destPos.y, 40, 0, Math.PI, false); ctx.fill();

            // Draw Balls
            robot.balls.forEach(b => {
                ctx.fillStyle = b.state === 'DEST' ? '#10b981' : (b.state === 'HELD' ? '#fff' : '#f59e0b');
                ctx.beginPath(); ctx.arc(b.x, b.y, 8, 0, Math.PI * 2); ctx.fill();
            });

            // Inverse Kinematics for Arm
            const L1 = 180;
            const L2 = 160;
            const dx = robot.current.x - cx;
            const dy = robot.current.y - cy;
            const distToTarget = Math.sqrt(dx * dx + dy * dy);
            const clampedDist = Math.min(distToTarget, L1 + L2 - 1);

            const a1 = Math.atan2(dy, dx);
            const a2 = Math.acos((L1 * L1 + clampedDist * clampedDist - L2 * L2) / (2 * L1 * clampedDist));

            const angle1 = a1 - a2;
            const j1x = cx + Math.cos(angle1) * L1;
            const j1y = cy + Math.sin(angle1) * L1;

            // Draw Arm
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Base
            ctx.fillStyle = '#444';
            ctx.fillRect(cx - 20, cy - 10, 40, 20);

            // Segment 1
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 16;
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(j1x, j1y); ctx.stroke();

            // Segment 2
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 12;
            ctx.beginPath(); ctx.moveTo(j1x, j1y); ctx.lineTo(robot.current.x, robot.current.y); ctx.stroke();

            // Joints
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(j1x, j1y, 8, 0, Math.PI * 2); ctx.fill();

            // Gripper
            ctx.fillStyle = '#ef4444';
            ctx.beginPath(); ctx.arc(robot.current.x, robot.current.y, 10, 0, Math.PI * 2); ctx.fill();

            // Helper func
            function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
        }

        function renderEnergy(w, h, t) {
            const efficiency = simParams.p1;
            const cellSize = 20;
            const cols = Math.ceil(w / cellSize);
            const rows = Math.ceil(h / cellSize);

            // Cellular Automaton Grid
            if (!simState.grid || simState.grid.length !== cols * rows) {
                simState.grid = new Array(cols * rows).fill(0);
                // Seed center
                const cx = Math.floor(cols / 2);
                const cy = Math.floor(rows / 2);
                simState.grid[cy * cols + cx] = 1;
            }

            // Growth Logic (runs every few frames)
            if (Math.floor(t * 60) % 5 === 0) {
                const newGrid = [...simState.grid];
                const growthRate = efficiency / 200; // 0 to 0.5 chance

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const idx = y * cols + x;
                        if (simState.grid[idx] === 1) {
                            // Try to grow neighbors
                            const neighbors = [
                                idx - 1, idx + 1, idx - cols, idx + cols
                            ];
                            neighbors.forEach(n => {
                                if (n >= 0 && n < newGrid.length && newGrid[n] === 0) {
                                    if (Math.random() < growthRate) newGrid[n] = 1;
                                }
                            });
                        }
                    }
                }
                simState.grid = newGrid;
            }

            // Reset if efficiency is low
            if (efficiency < 5) {
                simState.grid.fill(0);
                simState.grid[Math.floor(rows / 2) * cols + Math.floor(cols / 2)] = 1;
            }

            // Draw
            let activeCount = 0;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (simState.grid[y * cols + x] === 1) {
                        activeCount++;
                        const px = x * cellSize;
                        const py = y * cellSize;

                        // Color gradient from center
                        const dist = Math.hypot(x - cols / 2, y - rows / 2);
                        const hue = 200 + (dist * 5) % 50;

                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(px, py, cellSize - 1, cellSize - 1);

                        // Sparkle
                        if (Math.random() > 0.98) {
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(px, py, cellSize - 1, cellSize - 1);
                        }
                    }
                }
            }

            // Stats
            const coverage = (activeCount / (cols * rows)) * 100;
            const cost = Math.max(0, 100 - (coverage * 2)); // Cost drops as coverage grows

            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(20, h - 60, 300, 40);
            ctx.fillStyle = '#fff';
            ctx.font = '20px monospace';
            ctx.fillText(`ENERGY COST: $${cost.toFixed(2)}/MWh`, 30, h - 35);
        }

        function renderBoom(w, h, t) {
            const auto = simParams.p1;
            const graphH = h * 0.6;
            const graphY = 50;

            // Grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(50, graphY + graphH); ctx.lineTo(w - 50, graphY + graphH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(50, graphY + graphH); ctx.lineTo(50, graphY); ctx.stroke();

            // GDP (Yellow)
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#f59e0b';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(50, graphY + graphH);
            for (let x = 50; x < w - 50; x += 5) {
                const progress = (x - 50) / (w - 100);
                const y = (graphY + graphH) - (progress * progress * 200) - (progress * auto * 2.5);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Wages (Green)
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#10b981';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(50, graphY + graphH);
            for (let x = 50; x < w - 50; x += 5) {
                const progress = (x - 50) / (w - 100);
                let y = (graphY + graphH) - (progress * 100);
                if (progress > 0.6) y += (progress - 0.6) * 50 * (auto / 50);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 16px sans-serif'; ctx.fillText("GDP (Corporate Profits)", w - 250, graphY + graphH - 220);
            ctx.fillStyle = '#10b981'; ctx.fillText("Median Wage", w - 250, graphY + graphH - 60);
        }

        function renderSqueeze(w, h, t) {
            const pressure = simParams.p1; // 0 to 100

            if (!simState.workers) {
                simState.workers = [];
                for (let i = 0; i < 100; i++) {
                    simState.workers.push({
                        x: Math.random() * w,
                        y: Math.random() * (h - 150),
                        vy: 0,
                        solvent: true,
                        r: 4 + Math.random() * 4
                    });
                }
            }

            simState.workers.forEach((p, i) => {
                // Insolvency check
                const threshold = (100 - pressure) / 100;
                const resilience = (i / 100);
                p.solvent = resilience < threshold;

                if (!p.solvent) {
                    p.vy += 0.2; // Gravity
                    p.y += p.vy;
                } else {
                    p.y += Math.sin(t + i) * 0.2; // Float
                    p.vy = 0;
                }

                ctx.fillStyle = p.solvent ? '#10b981' : '#ef4444';
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
            });

            // "The Floor"
            ctx.fillStyle = '#ef4444';
            ctx.globalAlpha = 0.2;
            ctx.fillRect(0, h, w, -50);
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText("INSOLVENCY ZONE", w / 2, h - 20);
        }

        function renderFreeze(w, h, t) {
            const concentration = simParams.p1;
            const particleCount = 100;
            if (!simState.freeze) {
                simState.freeze = Array.from({ length: particleCount }, () => ({
                    x: Math.random() * w, y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8
                }));
            }

            const speedMod = Math.max(0.00, 1 - (concentration / 95)); // Stops completely at high wealth

            simState.freeze.forEach(p => {
                p.x += p.vx * speedMod;
                p.y += p.vy * speedMod;
                if (p.x < 0 || p.x > w) p.vx *= -1;
                if (p.y < 0 || p.y > h) p.vy *= -1;

                const speed = Math.hypot(p.vx * speedMod, p.vy * speedMod);
                const color = speed < 0.1 ? '#555' : '#10b981';

                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
            });

            // Black Hole of Wealth
            const r = (concentration / 100) * 150;
            ctx.fillStyle = 'rgba(245, 158, 11, 0.2)';
            ctx.beginPath(); ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#f59e0b';
            ctx.beginPath(); ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2); ctx.stroke();

            if (concentration > 90) {
                ctx.fillStyle = '#ef4444';
                ctx.font = '30px monospace';
                ctx.textAlign = 'center';
                ctx.fillText("VELOCITY: ZERO", w / 2, h / 2);
            }
        }

        function renderCrash(w, h, t) {
            const year = simParams.p1;
            const progress = (year - 2040) / 30;
            const isCrash = year >= 2060;

            // Screen Shake
            let sx = 0, sy = 0;
            if (isCrash) {
                sx = (Math.random() - 0.5) * 10;
                sy = (Math.random() - 0.5) * 10;
            }
            ctx.save();
            ctx.translate(sx, sy);

            // Background Warning
            if (isCrash) {
                ctx.fillStyle = `rgba(239, 68, 68, ${0.1 + Math.sin(t * 10) * 0.05})`;
                ctx.fillRect(0, 0, w, h);

                // Binary Rain
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.font = '14px monospace';
                for (let i = 0; i < 20; i++) {
                    ctx.fillText(Math.random() > 0.5 ? '1' : '0', Math.random() * w, Math.random() * h);
                }
            }

            // Graph Layout
            const pad = 60;
            const graphW = w - pad * 2;
            const graphH = h - pad * 2;
            const originX = pad;
            const originY = h - pad;

            // Axes
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(originX + graphW, originY); ctx.stroke(); // X
            ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(originX, pad); ctx.stroke(); // Y

            // 1. Productivity (Blue - Exponential)
            ctx.strokeStyle = '#06b6d4';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#06b6d4'; ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(originX, originY - graphH * 0.2); // Start a bit up

            // Draw full curve up to current year
            for (let i = 0; i <= progress * 100; i++) {
                const p = i / 100; // 0 to progress
                const x = originX + p * graphW;
                const y = (originY - graphH * 0.2) - (p * p * graphH * 0.8);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Label
            if (progress > 0.1) {
                ctx.fillStyle = '#06b6d4';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText("PRODUCTIVITY", originX + 10, originY - graphH * 0.2 - 20);
            }

            // 2. Employment (Green -> Red Crash)
            // We draw this in two segments: Pre-2060 and Post-2060

            const crashP = (2060 - 2040) / 30; // ~0.66

            // Segment 1: Stable (Green)
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#10b981'; ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(originX, originY - graphH * 0.6); // Start high

            const endStable = Math.min(progress, crashP);
            for (let i = 0; i <= endStable * 100; i++) {
                const p = i / 100;
                const x = originX + p * graphW;
                // Slight decline before crash
                const y = (originY - graphH * 0.6) + (p * graphH * 0.1);
                ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Segment 2: The Crash (Red)
            if (progress > crashP) {
                ctx.strokeStyle = '#ef4444';
                ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 20;
                ctx.beginPath();
                // Start where green left off
                const startX = originX + crashP * graphW;
                const startY = (originY - graphH * 0.6) + (crashP * graphH * 0.1);
                ctx.moveTo(startX, startY);

                for (let i = Math.floor(crashP * 100); i <= progress * 100; i++) {
                    const p = i / 100;
                    const localP = (p - crashP) / (1 - crashP); // 0 to 1 during crash phase
                    const x = originX + p * graphW;

                    // Dramatic drop with noise
                    let y = startY + (localP * graphH * 0.8); // Drop 80% of height
                    y += (Math.random() - 0.5) * 20; // Jitter

                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Employment Label
            ctx.fillStyle = isCrash ? '#ef4444' : '#10b981';
            ctx.fillText("EMPLOYMENT", originX + 10, originY - graphH * 0.6 - 10);

            // Big Overlay Text
            if (isCrash) {
                ctx.save();
                ctx.translate(w / 2, h / 2);
                ctx.rotate(-0.1);
                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.font = '900 60px sans-serif';
                ctx.shadowColor = '#000'; ctx.shadowBlur = 20;
                ctx.fillText("SYSTEM FAILURE", 0, 0);

                ctx.font = '20px monospace';
                ctx.fillStyle = '#fff';
                ctx.fillText("DEMAND COLLAPSE // UNEMPLOYMENT > 60%", 0, 40);
                ctx.restore();

                // Binary Rain
                ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.font = '12px monospace';
                for (let i = 0; i < 20; i++) {
                    ctx.fillText(Math.random() > 0.5 ? "1" : "0", Math.random() * w, Math.random() * h);
                }
            }

            ctx.restore();
        }

        function renderStimulus(w, h, t) {
            const cx = w / 2;
            const cy = h / 2;
            const bucketW = 200;
            const bucketH = 220;
            const floorY = cy + 100;
            const holeW = 80; // Wider hole
            const tilt = 40; // Steeper tilt

            // 1. Draw Container (Glass)
            ctx.save();
            ctx.shadowColor = 'rgba(255,255,255,0.2)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            // Left Wall
            ctx.moveTo(cx - bucketW / 2, cy - bucketH / 2);
            ctx.lineTo(cx - bucketW / 2, floorY - tilt);
            // Left Floor (Tilted)
            ctx.lineTo(cx - holeW / 2, floorY);
            // Right Floor (Tilted)
            ctx.moveTo(cx + holeW / 2, floorY);
            ctx.lineTo(cx + bucketW / 2, floorY - tilt);
            // Right Wall
            ctx.lineTo(cx + bucketW / 2, cy - bucketH / 2);
            ctx.stroke();

            // Label
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText("THE LABOR MARKET", cx, floorY + 30);

            ctx.shadowBlur = 0;
            ctx.restore();

            // 2. Particle System
            if (!simState.droplets) simState.droplets = [];

            // Emitter (The Stimulus)
            if (simState.stimulusActive) {
                // Pour MORE particles (smaller)
                for (let i = 0; i < 20; i++) {
                    simState.droplets.push({
                        x: cx + (Math.random() - 0.5) * 40,
                        y: cy - bucketH / 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: 5 + Math.random() * 5,
                        r: 1.5 + Math.random() * 1.5,
                        life: 300
                    });
                }
                // Timer logic
                if (!simState.timer) simState.timer = 0;
                simState.timer++;
                if (simState.timer > 60) { // 1 second pour (shorter)
                    simState.stimulusActive = false;
                    simState.timer = 0;
                }
            }

            // Physics & Render
            ctx.fillStyle = '#06b6d4'; // Cyan Water

            simState.droplets.forEach(p => {
                p.vy += 0.3; // Gravity
                p.x += p.vx;
                p.y += p.vy;

                // Floor Collision (Tilted)
                let floorHeightAtX = floorY;

                // Left Side
                if (p.x < cx - holeW / 2 && p.x > cx - bucketW / 2) {
                    const progress = (p.x - (cx - bucketW / 2)) / ((bucketW - holeW) / 2);
                    floorHeightAtX = (floorY - tilt) + progress * tilt;

                    if (p.y > floorHeightAtX - p.r) {
                        p.y = floorHeightAtX - p.r;
                        // Slide towards center (positive x)
                        p.vx += 0.8; // Stronger slide
                        p.vy *= -0.4; // Dampen
                        p.vx *= 0.9;  // Friction
                    }
                }
                // Right Side
                else if (p.x > cx + holeW / 2 && p.x < cx + bucketW / 2) {
                    const progress = ((cx + bucketW / 2) - p.x) / ((bucketW - holeW) / 2);
                    floorHeightAtX = (floorY - tilt) + progress * tilt;

                    if (p.y > floorHeightAtX - p.r) {
                        p.y = floorHeightAtX - p.r;
                        // Slide towards center (negative x)
                        p.vx -= 0.8; // Stronger slide
                        p.vy *= -0.4; // Dampen
                        p.vx *= 0.9;  // Friction
                    }
                }

                // Wall Collision
                if (p.x < cx - bucketW / 2 + p.r) {
                    p.x = cx - bucketW / 2 + p.r;
                    p.vx *= -0.5;
                }
                if (p.x > cx + bucketW / 2 - p.r) {
                    p.x = cx + bucketW / 2 - p.r;
                    p.vx *= -0.5;
                }

                // Draw
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fill();

                // Cleanup
                if (p.y > h) p.life = 0;
            });

            // Remove dead particles
            simState.droplets = simState.droplets.filter(p => p.life > 0);

            // Text Overlay
            if (simState.droplets.length === 0 && !simState.stimulusActive) {
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '16px monospace';
                ctx.fillText("SYSTEM READY FOR INJECTION", cx, cy - 60);
            } else if (simState.droplets.length > 0) {
                // Count particles in bucket
                const trapped = simState.droplets.filter(p => p.y < floorY && p.y > floorY - 50).length;
                if (trapped < 10 && !simState.stimulusActive) {
                    ctx.fillStyle = '#ef4444';
                    ctx.textAlign = 'center';
                    ctx.fillText("LIQUIDITY DRAINING...", cx, cy - 20);
                }
            }
        }
        window.triggerStimulus = () => { simState.stimulusActive = true; }

        function renderScale(w, h, t) {
            // Circuit Rewiring
            const shift = simParams.p1; // 0 to 100

            const prodX = w * 0.2;
            const consX = w * 0.8;
            const laborY = h * 0.8;
            const directY = h * 0.2;

            // Nodes
            ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(prodX, h / 2, 30, 0, Math.PI * 2); ctx.fill(); // Prod
            ctx.fillStyle = '#fff'; ctx.fillText("PRODUCTION", prodX, h / 2 + 50);

            ctx.fillStyle = '#10b981'; ctx.beginPath(); ctx.arc(consX, h / 2, 30, 0, Math.PI * 2); ctx.fill(); // Cons
            ctx.fillStyle = '#fff'; ctx.fillText("CONSUMPTION", consX, h / 2 + 50);

            // Old Path (Labor)
            ctx.strokeStyle = '#555'; ctx.lineWidth = 8;
            ctx.beginPath(); ctx.moveTo(prodX, h / 2); ctx.lineTo(w / 2, laborY); ctx.lineTo(consX, h / 2); ctx.stroke();

            // New Path (Direct) - Opacity based on shift
            ctx.strokeStyle = `rgba(6, 182, 212, ${shift / 100})`;
            ctx.lineWidth = 8 + (Math.sin(t * 10) * 2); // Pulse
            ctx.shadowColor = '#06b6d4'; ctx.shadowBlur = shift / 5;
            ctx.beginPath(); ctx.moveTo(prodX, h / 2); ctx.lineTo(w / 2, directY); ctx.lineTo(consX, h / 2); ctx.stroke();
            ctx.shadowBlur = 0;

            // Electrons
            if (Math.floor(t * 10) % 3 === 0) {
                if (!simState.electrons) simState.electrons = [];
                simState.electrons.push({ p: 0, path: shift > 50 ? 'new' : 'old' });
            }

            if (simState.electrons) {
                simState.electrons.forEach((e, i) => {
                    e.p += 0.02;
                    let ex, ey;
                    if (e.path === 'old') {
                        if (e.p < 0.5) {
                            ex = prodX + (w / 2 - prodX) * (e.p * 2);
                            ey = h / 2 + (laborY - h / 2) * (e.p * 2);
                        } else {
                            ex = w / 2 + (consX - w / 2) * ((e.p - 0.5) * 2);
                            ey = laborY + (h / 2 - laborY) * ((e.p - 0.5) * 2);
                        }
                        // Broken path effect
                        if (shift > 20 && Math.random() > 0.8) ctx.fillStyle = 'red';
                        else ctx.fillStyle = '#fff';
                    } else {
                        if (e.p < 0.5) {
                            ex = prodX + (w / 2 - prodX) * (e.p * 2);
                            ey = h / 2 + (directY - h / 2) * (e.p * 2);
                        } else {
                            ex = w / 2 + (consX - w / 2) * ((e.p - 0.5) * 2);
                            ey = directY + (h / 2 - directY) * ((e.p - 0.5) * 2);
                        }
                        ctx.fillStyle = '#06b6d4';
                    }

                    ctx.beginPath(); ctx.arc(ex, ey, 6, 0, Math.PI * 2); ctx.fill();
                    if (e.p >= 1) simState.electrons.splice(i, 1);
                });
            }
        }

        function renderDividend(w, h, t) {
            const flow = simParams.p1;

            // Factory
            ctx.fillStyle = '#333'; ctx.fillRect(50, h / 2 - 40, 80, 80);
            ctx.fillStyle = '#f59e0b'; ctx.fillText("ROBOTS", 60, h / 2 + 5);

            // People
            ctx.fillStyle = '#333'; ctx.fillRect(w - 130, h / 2 - 40, 80, 80);
            ctx.fillStyle = '#10b981'; ctx.fillText("PEOPLE", w - 120, h / 2 + 5);

            // Pipes
            ctx.strokeStyle = '#444'; ctx.lineWidth = 20;
            ctx.beginPath(); ctx.moveTo(130, h / 2); ctx.lineTo(w - 130, h / 2); ctx.stroke();

            // Valve
            ctx.fillStyle = flow > 0 ? '#10b981' : '#ef4444';
            ctx.fillRect(w / 2 - 15, h / 2 - 30, 30, 60);

            // Particles
            if (flow > 0) {
                if (Math.random() < flow / 50) {
                    if (!simState.divs) simState.divs = [];
                    simState.divs.push({ x: 130, y: h / 2 + (Math.random() - 0.5) * 10 });
                }
            }

            if (simState.divs) {
                simState.divs.forEach((d, i) => {
                    d.x += 8;
                    ctx.fillStyle = '#10b981';
                    ctx.beginPath(); ctx.arc(d.x, d.y, 5, 0, Math.PI * 2); ctx.fill();
                    if (d.x > w - 130) simState.divs.splice(i, 1);
                });
            }
        }

        function renderPurpose(w, h, t) {
            const focus = simParams.p1; // 0 to 100
            const vitality = focus / 100; // 0 to 1

            // Initialize Seed
            if (!simState.seed) simState.seed = 12345;

            // Stateless PRNG (Hash)
            function hash(n) {
                return Math.abs(Math.sin(n * 12.9898 + simState.seed) * 43758.5453) % 1;
            }

            // 1. Background
            const r = 10 + (200 * vitality);
            const g = 15 + (180 * vitality);
            const b = 30 + (100 * vitality);

            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, `rgb(${r * 0.5}, ${g * 0.5}, ${b * 0.8})`);
            grad.addColorStop(1, `rgb(${r}, ${g}, ${b})`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Sun
            const sunY = h * 0.8 - (h * 0.6 * vitality);
            ctx.fillStyle = `rgba(255, 255, 200, ${0.1 + vitality * 0.4})`;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 20 + vitality * 50;
            ctx.beginPath(); ctx.arc(w / 2, sunY, 40 + vitality * 40, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;

            // 2. Birds
            if (vitality > 0.4) {
                if (!simState.birds) {
                    simState.birds = Array.from({ length: 10 }, (_, i) => ({
                        x: Math.random() * w,
                        y: Math.random() * h * 0.5,
                        speed: 0.5 + Math.random(),
                        offset: Math.random() * 100
                    }));
                }

                ctx.fillStyle = `rgba(0,0,0,${vitality})`;
                simState.birds.forEach(bird => {
                    bird.x += bird.speed;
                    if (bird.x > w) bird.x = -20;

                    const flyY = bird.y + Math.sin(t * 2 + bird.offset) * 10;
                    const wing = Math.sin(t * 10 + bird.offset) * 5;

                    ctx.beginPath();
                    ctx.moveTo(bird.x, flyY);
                    ctx.lineTo(bird.x - 5, flyY - wing); // Left wing
                    ctx.lineTo(bird.x + 5, flyY - wing); // Right wing
                    ctx.lineTo(bird.x, flyY + 2); // Body
                    ctx.fill();
                });
            }

            // 3. Stable Procedural Tree
            const cx = w / 2;
            const cy = h;
            const maxDepth = 10;

            // Wind
            const wind = Math.sin(t * 0.5) * 2 + Math.sin(t * 1.5) * 0.5;

            // Recursive function passes a unique 'id' for randomness
            function drawBranch(x, y, len, angle, width, depth, id) {
                ctx.beginPath();
                ctx.save();

                // Properties derived from ID (Stable)
                const rCurve = hash(id + 1);
                const rBranchCount = hash(id + 2);

                // Color
                if (depth < 3) ctx.strokeStyle = '#5d4037';
                else ctx.strokeStyle = vitality > 0.5 ? '#10b981' : '#8b5a2b';

                ctx.lineWidth = width;
                ctx.translate(x, y);

                const finalAngle = angle + (wind * (depth * 0.5));
                ctx.rotate(finalAngle * Math.PI / 180);

                ctx.moveTo(0, 0);
                const curveX = (rCurve - 0.5) * 20;
                ctx.quadraticCurveTo(curveX, -len / 2, 0, -len);
                ctx.stroke();

                if (depth >= maxDepth || len < 5) {
                    // Flowers
                    const rFlower = hash(id + 3);
                    if (vitality > 0.3 && rFlower > 0.5) {
                        const type = hash(id + 4);
                        ctx.fillStyle = type > 0.7 ? '#f59e0b' : (type > 0.4 ? '#ec4899' : '#10b981');
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.shadowBlur = vitality * 10;

                        const size = (vitality * 6) * hash(id + 5);
                        if (size > 0) {
                            ctx.beginPath();
                            ctx.arc(0, -len, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                    }
                    ctx.restore();
                    return;
                }

                // Branching
                const growthThreshold = depth / maxDepth;
                if (vitality > growthThreshold - 0.2) {
                    const branchCount = 2 + Math.floor(rBranchCount * 1.5); // 2 or 3

                    for (let i = 0; i < branchCount; i++) {
                        // Unique ID for child: ParentID * Prime + Index
                        const childId = id * 13 + i * 7;

                        const rLen = hash(childId + 10);
                        const rSpread = hash(childId + 11);
                        const rAngle = hash(childId + 12);

                        const nextLen = len * (0.6 + rLen * 0.2);
                        const nextWidth = width * 0.7;
                        const spread = 20 + rSpread * 40;
                        const nextAngle = -spread / 2 + (spread * i) + (rAngle - 0.5) * 20;

                        drawBranch(0, -len, nextLen, nextAngle, nextWidth, depth + 1, childId);
                    }
                }

                ctx.restore();
            }

            // Start Tree with ID 1
            const baseLen = 100 + hash(simState.seed) * 40;
            drawBranch(cx, cy, baseLen * (0.2 + vitality * 0.8), 0, 15, 0, 1);

            // 4. Particles
            if (vitality > 0.3) {
                if (Math.random() < vitality * 0.2) {
                    if (!simState.pollen) simState.pollen = [];
                    simState.pollen.push({
                        x: cx + (Math.random() - 0.5) * 300,
                        y: h - Math.random() * 300,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2,
                        life: 1
                    });
                }
            }

            if (simState.pollen) {
                simState.pollen.forEach((p, i) => {
                    p.x += p.vx + Math.sin(t + p.y * 0.01);
                    p.y += p.vy;
                    p.life -= 0.01;
                    ctx.fillStyle = `rgba(255, 215, 0, ${p.life})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill();
                    if (p.life <= 0) simState.pollen.splice(i, 1);
                });
            }

            if (vitality < 0.1) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'center';
                ctx.font = '14px monospace';
                ctx.fillText("The seed is dormant...", cx, h - 20);
            }
        }

        function renderStatus(w, h, t) {
            const reach = simParams.p1; // 10-100 Speed/Range
            const stickiness = simParams.p2 || 50; // 10-100 Conversion Power

            // Initialize Battle
            if (!simState.boids) {
                simState.boids = [];
                // 100 Grey (Public)
                for (let i = 0; i < 100; i++) simState.boids.push(createBoid(w, h, 'grey'));
                // 5 Red (Enemy)
                for (let i = 0; i < 5; i++) simState.boids.push(createBoid(w, h, 'red'));
                // 5 Blue (Player)
                for (let i = 0; i < 5; i++) simState.boids.push(createBoid(w, h, 'blue'));
            }

            // Stats
            let blueCount = 0;
            let redCount = 0;

            // Update Boids
            simState.boids.forEach(b => {
                if (b.team === 'blue') blueCount++;
                if (b.team === 'red') redCount++;

                // 1. Physics (Flocking + Pursuit)
                let alignX = 0, alignY = 0;
                let cohX = 0, cohY = 0;
                let sepX = 0, sepY = 0;
                let targetX = 0, targetY = 0;
                let neighborCount = 0;

                // Find neighbors
                simState.boids.forEach(other => {
                    if (b === other) return;
                    const dx = other.x - b.x;
                    const dy = other.y - b.y;
                    const dist = Math.hypot(dx, dy);

                    // Flocking (Same Team)
                    if (b.team === other.team && dist < 50) {
                        alignX += other.vx;
                        alignY += other.vy;
                        cohX += other.x;
                        cohY += other.y;
                        neighborCount++;
                    }

                    // Separation (Everyone)
                    if (dist < 20) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                    }

                    // Pursuit/Battle (Different Team)
                    // Blue chases Grey/Red. Red chases Grey/Blue.
                    if (b.team !== 'grey' && other.team !== b.team && dist < 150) {
                        // Attract to convertible targets
                        targetX += other.x;
                        targetY += other.y;
                    }
                });

                // Apply Flocking Forces
                if (neighborCount > 0) {
                    alignX /= neighborCount; alignY /= neighborCount;
                    cohX /= neighborCount; cohY /= neighborCount;

                    // Steer towards cohesion
                    b.vx += (cohX - b.x) * 0.005;
                    b.vy += (cohY - b.y) * 0.005;
                    // Match velocity
                    b.vx += (alignX - b.vx) * 0.01;
                    b.vy += (alignY - b.vy) * 0.01;
                }

                // Apply Separation
                b.vx += sepX * 0.5;
                b.vy += sepY * 0.5;

                // Apply Targeting (The "Reach" param affects how aggressive Blue is)
                if (b.team === 'blue') {
                    const aggression = reach / 5000;
                    b.vx += (targetX - b.x) * aggression;
                    b.vy += (targetY - b.y) * aggression;
                } else if (b.team === 'red') {
                    b.vx += (targetX - b.x) * 0.01; // Fixed aggression for Red
                    b.vy += (targetY - b.y) * 0.01;
                }

                // Friction & Speed Limit
                const speed = Math.hypot(b.vx, b.vy);
                const maxSpeed = b.team === 'blue' ? (2 + reach / 20) : 3; // Blue speed depends on Reach
                if (speed > maxSpeed) {
                    b.vx = (b.vx / speed) * maxSpeed;
                    b.vy = (b.vy / speed) * maxSpeed;
                }

                // Move
                b.x += b.vx;
                b.y += b.vy;

                // Wrap
                if (b.x < 0) b.x = w; if (b.x > w) b.x = 0;
                if (b.y < 0) b.y = h; if (b.y > h) b.y = 0;

                // 2. Infection / Combat Logic
                simState.boids.forEach(other => {
                    if (b === other) return;
                    const dx = other.x - b.x;
                    const dy = other.y - b.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < 10) {
                        // Collision!
                        if (b.team === 'blue' && other.team !== 'blue') {
                            // Blue tries to convert
                            // Chance = Stickiness vs Resistance
                            // Grey has low resistance. Red has high.
                            let chance = stickiness / 100;
                            if (other.team === 'red') chance *= 0.2; // Hard to convert Red

                            if (Math.random() < chance) {
                                other.team = 'blue';
                                // Spark effect
                                ctx.fillStyle = '#fff';
                                ctx.beginPath(); ctx.arc(other.x, other.y, 10, 0, Math.PI * 2); ctx.fill();
                            }
                        } else if (b.team === 'red' && other.team !== 'red') {
                            // Red tries to convert
                            if (Math.random() < 0.05) { // Fixed Red power
                                other.team = 'red';
                            }
                        }
                    }
                });

                // 3. Draw
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(Math.atan2(b.vy, b.vx));

                if (b.team === 'blue') {
                    ctx.fillStyle = '#06b6d4';
                    ctx.shadowColor = '#06b6d4'; ctx.shadowBlur = 10;
                } else if (b.team === 'red') {
                    ctx.fillStyle = '#ef4444';
                    ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 10;
                } else {
                    ctx.fillStyle = '#475569'; // Grey
                    ctx.shadowBlur = 0;
                }

                // Triangle
                ctx.beginPath();
                ctx.moveTo(6, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.fill();
                ctx.restore();
            });

            // Score Overlay
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#06b6d4'; ctx.fillText(`BLUE: ${blueCount}`, 20, 40);
            ctx.fillStyle = '#ef4444'; ctx.fillText(`RED:  ${redCount}`, 20, 70);

            if (blueCount > 90) {
                ctx.textAlign = 'center';
                ctx.fillStyle = '#06b6d4';
                ctx.font = 'bold 40px sans-serif';
                ctx.fillText("NARRATIVE DOMINANCE", w / 2, h / 2);
            }
        }

        function createBoid(w, h, team) {
            return {
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                team: team
            };
        }

        window.resetStatusSim = () => {
            simState.boids = null;
        };

        function renderLand(w, h, t) {
            const mode = simParams.p1; // 0 Market, 1 Access

            // Map Zones
            const zones = [
                { id: 'A', color: '#f59e0b', x: 50, y: 50, w: w / 2 - 60, h: h / 2 - 60, label: "ZONE A (Beach)" },
                { id: 'B', color: '#06b6d4', x: w / 2 + 10, y: 50, w: w / 2 - 60, h: h / 2 - 60, label: "ZONE B (City)" },
                { id: 'C', color: '#10b981', x: 50, y: h / 2 + 10, w: w / 2 - 60, h: h / 2 - 60, label: "ZONE C (Forest)" },
                { id: 'D', color: '#94a3b8', x: w / 2 + 10, y: h / 2 + 10, w: w / 2 - 60, h: h / 2 - 60, label: "ZONE D (Suburbs)" },
            ];

            zones.forEach(z => {
                ctx.fillStyle = z.color;
                ctx.globalAlpha = 0.2;
                ctx.fillRect(z.x, z.y, z.w, z.h);
                ctx.globalAlpha = 1;
                ctx.strokeStyle = z.color;
                ctx.strokeRect(z.x, z.y, z.w, z.h);
                ctx.fillStyle = '#fff';
                ctx.fillText(z.label, z.x + 20, z.y + 30);
            });

            // Player Dot
            if (!simState.playerPos) simState.playerPos = { x: zones[3].x + 50, y: zones[3].y + 50, target: 3 };

            if (mode === 1) {
                // Access Mode: Move between zones
                if (Math.floor(t) % 3 === 0 && Math.random() < 0.05) {
                    const nextZoneIdx = Math.floor(Math.random() * 4);
                    const z = zones[nextZoneIdx];
                    simState.playerPos.targetX = z.x + z.w / 2 + (Math.random() - 0.5) * 50;
                    simState.playerPos.targetY = z.y + z.h / 2 + (Math.random() - 0.5) * 50;
                }

                if (simState.playerPos.targetX) {
                    simState.playerPos.x += (simState.playerPos.targetX - simState.playerPos.x) * 0.05;
                    simState.playerPos.y += (simState.playerPos.targetY - simState.playerPos.y) * 0.05;
                }
            } else {
                // Market Mode: Stuck in D
                const z = zones[3];
                simState.playerPos.x += (z.x + z.w / 2 - simState.playerPos.x) * 0.1;
                simState.playerPos.y += (z.y + z.h / 2 - simState.playerPos.y) * 0.1;
            }

            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.arc(simState.playerPos.x, simState.playerPos.y, 10, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillText("YOU", simState.playerPos.x - 15, simState.playerPos.y - 20);
        }

        function renderGuardrails(w, h, t) {
            const speed = simParams.p1;
            const cx = w / 2, cy = h / 2;
            const risk = speed > 80 ? (speed - 80) : 0;
            const shakeX = (Math.random() - 0.5) * risk;
            const shakeY = (Math.random() - 0.5) * risk;

            // Core
            ctx.fillStyle = speed > 80 ? '#ef4444' : '#06b6d4';
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = speed;
            ctx.beginPath(); ctx.arc(cx + shakeX, cy + shakeY, 30 + (Math.sin(t * 10) * 5), 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;

            // Rings
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(cx, cy, 60, t, t + Math.PI); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, cy, 80, -t, -t + Math.PI); ctx.stroke();

            if (speed > 80) {
                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.font = 'bold 20px monospace';
                ctx.fillText("WARNING: CONTAINMENT BREACH", cx, cy + 120);
            } else {
                ctx.fillStyle = '#10b981';
                ctx.textAlign = 'center';
                ctx.fillText("Systems Stable", cx, cy + 120);
            }
        }

        function renderSpace(w, h, t) {
            // Starfield (Parallax)
            if (!simState.stars) {
                simState.stars = Array.from({ length: 200 }, () => ({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    z: Math.random() * 2 + 0.5 // Speed/Depth
                }));
            }

            // Move Stars
            const speed = simState.launch ? (simState.launchTime * simState.launchTime * 0.5) : 0;
            simState.stars.forEach(s => {
                s.y += speed * s.z;
                if (s.y > h) { s.y = 0; s.x = Math.random() * w; }

                const brightness = Math.min(1, speed / 10 + 0.5);
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.fillRect(s.x, s.y, s.z, s.z * (1 + speed / 5)); // Stretch
            });

            // Earth (Fades out)
            if (!simState.launch || simState.launchTime < 5) {
                const earthY = h + (simState.launch ? simState.launchTime * 50 : 0);
                ctx.fillStyle = '#1d4ed8'; // Ocean
                ctx.beginPath(); ctx.arc(w / 2, earthY + 800, 900, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#10b981'; // Land
                ctx.beginPath(); ctx.arc(w / 2 + 100, earthY + 800, 850, 0, Math.PI * 2); ctx.fill();
            }

            // Ship
            const shipY = simState.launch ? (h - 100 - simState.launchTime * 2) : (h - 100);
            const shake = simState.launch ? (Math.random() - 0.5) * Math.min(5, simState.launchTime) : 0;

            ctx.save();
            ctx.translate(w / 2 + shake, Math.min(h / 2, shipY)); // Camera follows ship after midpoint

            // Rocket Body
            ctx.fillStyle = '#e2e8f0';
            ctx.beginPath();
            ctx.moveTo(0, -40);
            ctx.quadraticCurveTo(15, -10, 15, 30);
            ctx.lineTo(-15, 30);
            ctx.quadraticCurveTo(-15, -10, 0, -40);
            ctx.fill();

            // Fins
            ctx.fillStyle = '#ef4444';
            ctx.beginPath(); ctx.moveTo(-15, 10); ctx.lineTo(-25, 40); ctx.lineTo(-15, 30); ctx.fill();
            ctx.beginPath(); ctx.moveTo(15, 10); ctx.lineTo(25, 40); ctx.lineTo(15, 30); ctx.fill();

            // Window
            ctx.fillStyle = '#06b6d4';
            ctx.beginPath(); ctx.arc(0, -10, 5, 0, Math.PI * 2); ctx.fill();

            // Engine Plume
            if (simState.launch) {
                simState.launchTime += 0.05;

                ctx.fillStyle = '#f59e0b';
                ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(-10, 30);
                ctx.lineTo(0, 30 + 50 + Math.random() * 50 + (simState.launchTime * 10));
                ctx.lineTo(10, 30);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Particles
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc((Math.random() - 0.5) * 20, 30 + Math.random() * 50, Math.random() * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();

            // Text Overlay (Drawn last to be on top)
            if (!simState.launch) {
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '16px monospace';
                ctx.fillText("AWAITING LAUNCH COMMAND", w / 2, h / 2 - 60);
            } else if (simState.launchTime > 10) {
                ctx.save();
                // Apple Style: Clean, no glow, thin weight
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';

                // Main Title
                ctx.font = '300 50px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                ctx.letterSpacing = '2px';
                ctx.fillText("MISSION: CENTAURI", w / 2, h / 2 - 120);

                // Subtitle
                ctx.font = '400 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.letterSpacing = '1px';
                ctx.fillText("VELOCITY: 0.2c  |  ETA: 20 YEARS", w / 2, h / 2 - 80);

                ctx.restore();
            }
        }

        window.triggerLaunch = () => {
            simState.launch = true;
            simState.launchTime = 0;
        }
    </script>
</body>

</html>
