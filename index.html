<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Grand Archive: 2025-2150</title>
    <style>
        :root {
            --bg-dark: #050505;
            --bg-panel: #0f1115;
            --text-primary: #f0f4f8;
            --text-secondary: #94a3b8;
            --accent-cyan: #06b6d4;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-gold: #f59e0b;
            --border: 1px solid rgba(255, 255, 255, 0.08);
            --font-mono: 'Courier New', monospace;
            --font-sans: system-ui, -apple-system, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: var(--font-sans);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- INTRO OVERLAY --- */
        #introOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 1s ease-out;
        }

        .intro-content {
            max-width: 700px;
            padding: 40px;
            animation: fadeIn 2s ease-in;
        }

        .intro-title {
            font-size: 4rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #fff, #94a3b8);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -2px;
            font-weight: 800;
        }

        .intro-subtitle {
            font-family: var(--font-mono);
            color: var(--accent-cyan);
            font-size: 1rem;
            margin-bottom: 30px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .intro-text {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 50px;
            line-height: 1.6;
        }

        .lang-selection {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .lang-btn {
            background: transparent;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
            padding: 10px 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .lang-btn.active,
        .lang-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.2);
        }

        .enter-btn {
            background: var(--text-primary);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
        }

        .enter-btn.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .enter-btn:hover {
            background: var(--accent-cyan);
            box-shadow: 0 0 30px rgba(6, 182, 212, 0.4);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- LAYOUT --- */
        .main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
        }

        /* SIDEBAR (Timeline) */
        .sidebar {
            width: 280px;
            background: var(--bg-panel);
            border-right: var(--border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .timeline-item {
            padding: 15px 20px;
            border-bottom: var(--border);
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
            display: flex;
            flex-direction: column;
        }

        .timeline-item:hover {
            opacity: 0.8;
            background: rgba(255, 255, 255, 0.02);
        }

        .timeline-item.active {
            opacity: 1;
            background: rgba(6, 182, 212, 0.05);
            border-left: 3px solid var(--accent-cyan);
        }

        .t-year {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--accent-cyan);
            margin-bottom: 4px;
        }

        .t-title {
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* CENTER (Narrative) */
        .narrative {
            flex: 1;
            max-width: 500px;
            padding: 50px;
            overflow-y: auto;
            border-right: var(--border);
            background: radial-gradient(circle at top left, #14161f 0%, #0a0b10 100%);
            flex-shrink: 0;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 15px;
            color: white;
            letter-spacing: -1px;
            line-height: 1.1;
        }

        h2 {
            font-size: 0.8rem;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 30px;
            font-family: var(--font-mono);
            opacity: 0.8;
        }

        p {
            line-height: 1.8;
            color: var(--text-secondary);
            margin-bottom: 25px;
            font-size: 1.05rem;
        }

        strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* RIGHT (Simulation) */
        .simulation-area {
            flex: 1.5;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* CONTROLS OVERLAY */
        .controls-overlay {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 17, 21, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 16px;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            transition: opacity 0.3s;
            z-index: 10;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent-cyan);
            cursor: pointer;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* HEADER */
        header {
            height: 60px;
            border-bottom: var(--border);
            display: flex;
            align-items: center;
            padding: 0 25px;
            background: var(--bg-dark);
            justify-content: space-between;
        }

        .archive-status {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--accent-green);
            letter-spacing: 1px;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: 0.2s;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                height: auto;
                /* Allow scrolling */
            }

            /* 1. Simulation on Top */
            .simulation-area {
                order: 1;
                width: 100%;
                height: 40vh;
                /* Fixed height for sim */
                min-height: 300px;
                border-left: none;
                border-bottom: var(--border);
            }

            /* 2. Timeline Strip */
            .sidebar {
                order: 2;
                width: 100%;
                height: 70px;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                border-right: none;
                border-bottom: var(--border);
                padding: 10px;
                white-space: nowrap;
            }

            .timeline-item {
                display: inline-block;
                width: auto;
                min-width: 120px;
                margin-bottom: 0;
                margin-right: 10px;
                padding: 10px;
            }

            /* 3. Narrative Below */
            .narrative {
                order: 3;
                width: 100%;
                height: auto;
                padding: 20px;
                overflow-y: visible;
                /* Let page scroll */
            }

            /* Adjustments */
            header {
                font-size: 0.8rem;
                padding: 10px;
                text-align: center;
            }

            .archive-status {
                display: none;
                /* Hide status on small screens to save space */
            }

            .intro-title {
                font-size: 3rem;
            }

            .controls-overlay {
                width: 95%;
                bottom: 10px;
                padding: 15px;
            }
        }
    </style>
</head>

<body>

    <!-- INTRO OVERLAY -->
    <div id="introOverlay">
        <div class="intro-content">
            <div class="intro-subtitle">System Boot Sequence Initiated</div>
            <div class="intro-title">ARCHIVE 2150</div>
            <div class="intro-text" id="introText">
                In a world of emergent AI, discover the history of the future.<br>
                Become the historian of a society transformed.
            </div>

            <div class="lang-selection">
                <button class="lang-btn active" onclick="selectLang('en', this)">English</button>
                <button class="lang-btn" onclick="selectLang('fr', this)">Français</button>
            </div>

            <button class="enter-btn" id="enterBtn" onclick="startExperience()">ENTER ARCHIVE</button>
        </div>
    </div>

    <header>
        <div style="font-weight:800; letter-spacing: -0.5px;">ARCHIVE_2150 // HISTORICAL RECONSTRUCTION</div>
        <div class="archive-status">● SYSTEM ONLINE</div>
    </header>

    <div class="main-container">
        <!-- 1. TIMELINE -->
        <div class="sidebar" id="sidebar">
            <!-- Injected via JS -->
        </div>

        <!-- 2. NARRATIVE -->
        <div class="narrative" id="narrativeContent">
            <!-- Injected via JS -->
        </div>

        <!-- 3. SIMULATION -->
        <div class="simulation-area">
            <canvas id="simCanvas"></canvas>
            <div class="controls-overlay" id="simControls">
                <!-- Injected via JS -->
            </div>
        </div>
    </div>

    <script>
        /**
         * --- INTERNATIONALIZATION & DATA ---
         */
        const translations = {
            en: {
                title: "ARCHIVE_2150 // HISTORICAL RECONSTRUCTION",
                status: "● SYSTEM ONLINE",
                back: "&larr; Back",
                next: "Next Era &rarr;",
                intro: {
                    subtitle: "System Boot Sequence Initiated",
                    text: "In a world of emergent AI, discover the history of the future.<br>Become the historian of a society transformed.",
                    enter: "ENTER ARCHIVE"
                },
                controls: {
                    compute: "Compute Power",
                    autonomy: "AI Autonomy Level",
                    dexterity: "Robotic Dexterity",
                    solar: "Solar Efficiency",
                    auto: "Automation Integration",
                    pressure: "Corporate Cost Pressure",
                    wealth: "Wealth Concentration",
                    timeline: "Timeline",
                    stimulus: "INJECT $10 TRILLION",
                    ideology: "Ideological Shift",
                    valve: "Dividend Valve Flow",
                    focus: "Focus: Creativity",
                    metric: "Metric:",
                    market: "Market Mode",
                    access: "Access Mode",
                    research: "Research Speed",
                    launch: "INITIATE LAUNCH SEQUENCE"
                }
            },
            fr: {
                title: "ARCHIVE_2150 // RECONSTRUCTION HISTORIQUE",
                status: "● SYSTÈME EN LIGNE",
                back: "&larr; Retour",
                next: "Ère Suivante &rarr;",
                intro: {
                    subtitle: "Séquence de Démarrage Initiée",
                    text: "Dans un monde d'IA émergente, découvrez l'histoire du futur.<br>Devenez l'historien d'une société transformée.",
                    enter: "ENTRER DANS L'ARCHIVE"
                },
                controls: {
                    compute: "Puissance de Calcul",
                    autonomy: "Niveau d'Autonomie IA",
                    dexterity: "Dextérité Robotique",
                    solar: "Efficacité Solaire",
                    auto: "Intégration de l'Automatisation",
                    pressure: "Pression des Coûts",
                    wealth: "Concentration des Richesses",
                    timeline: "Chronologie",
                    stimulus: "INJECTER 10 BILLIONS $",
                    ideology: "Changement Idéologique",
                    valve: "Flux du Dividende",
                    focus: "Focus: Créativité",
                    metric: "Métrique:",
                    market: "Mode Marché",
                    access: "Mode Accès",
                    research: "Vitesse de Recherche",
                    launch: "LANCER LA SÉQUENCE"
                }
            }
        };

        let currentLang = 'en';

        function getChapters(lang) {
            const isEn = lang === 'en';
            return [
                {
                    year: "2025",
                    title: isEn ? "The Spark" : "L'Étincelle",
                    subtitle: isEn ? "Where we stand today" : "Où nous en sommes",
                    text: isEn ?
                        `<p>Welcome, student. You are accessing this archive from the year 2150. We are looking back at the most turbulent century in human history.</p>
                        <p>It starts in <strong>2025</strong>. At this moment, AI was still "Digital." Large Language Models (LLMs) could write code and poetry, but they were trapped in servers. They had no hands.</p>
                        <p>The economy was stable. People worked for wages. Capital (machines) and Labor (humans) were roughly balanced partners. But the spark had been lit. The cost of intelligence was dropping by 10x every year.</p>
                        <p><strong>Simulation:</strong> Observe the neural network. It is growing, but isolated. Adjust the <em>Compute Power</em> to see how the network density increases.</p>` :
                        `<p>Bienvenue, étudiant. Vous accédez à cette archive depuis l'an 2150. Nous regardons en arrière sur le siècle le plus turbulent de l'histoire humaine.</p>
                        <p>Tout commence en <strong>2025</strong>. À ce moment, l'IA était encore "Numérique". Les LLM pouvaient écrire du code et de la poésie, mais ils étaient piégés dans des serveurs. Ils n'avaient pas de mains.</p>
                        <p>L'économie était stable. Les gens travaillaient pour un salaire. Le Capital (machines) et le Travail (humains) étaient des partenaires à peu près équilibrés. Mais l'étincelle avait été allumée.</p>
                        <p><strong>Simulation :</strong> Observez le réseau neuronal. Il grandit, mais reste isolé. Ajustez la <em>Puissance de Calcul</em> pour voir la densité du réseau augmenter.</p>`,
                    simId: "SPARK",
                    controls: `<label>${translations[lang].controls.compute} <span id="val1">Low</span></label><input type="range" min="10" max="100" value="20" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2028-2032",
                    title: isEn ? "The Agentic Era" : "L'Ère Agentique",
                    subtitle: isEn ? "From Chatbots to Workers" : "Des Chatbots aux Travailleurs",
                    text: isEn ?
                        `<p>By roughly 2030, AI stopped being a "chatbot" and became an "Agent."</p>
                        <p>An Agent doesn't just talk; it <em>does</em>. It could browse the web, use software, send emails, and code entire apps without human intervention. This was the first wave of displacement: white-collar digital tasks.</p>
                        <p>Data entry, basic coding, translation, and customer service began to automate. However, the economy held up because new roles (supervisors, prompt engineers) were created.</p>
                        <p><strong>Simulation:</strong> Watch the "Swarm". Agents (Blue) actively hunt for tasks, moving faster and more efficiently than humans (Green).</p>` :
                        `<p>Vers 2030, l'IA a cessé d'être un "chatbot" pour devenir un "Agent".</p>
                        <p>Un Agent ne fait pas que parler ; il <em>agit</em>. Il pouvait naviguer sur le web, utiliser des logiciels et coder des applications entières sans intervention humaine.</p>
                        <p>La saisie de données, le codage de base et le service client ont commencé à s'automatiser. L'économie a tenu bon grâce à la création de nouveaux rôles.</p>
                        <p><strong>Simulation :</strong> Regardez l'essaim. Les agents (bleus) chassent activement les tâches, se déplaçant plus vite et plus efficacement que les humains (verts).</p>`,
                    simId: "AGENTS",
                    controls: `<label>${translations[lang].controls.autonomy} <span id="val1">0%</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2035-2040",
                    title: isEn ? "The Physical Link" : "Le Lien Physique",
                    subtitle: isEn ? "Robotics catches up" : "La robotique rattrape son retard",
                    text: isEn ?
                        `<p>For a long time, we thought blue-collar jobs were safe. "AI can't fix a clear plumbing pipe," we said.</p>
                        <p>We were wrong. By the late 2030s, humanoid robotics solved the battery and motor issues. Combined with the "Brain" of advanced AI, robots could now learn physical tasks by watching videos.</p>
                        <p>This was the turning point. Automation left the screen and entered the factory, the warehouse, and the construction site.</p>
                        <p><strong>Simulation:</strong> The robot arm. Increase <em>Dexterity</em> to see it match human speed and precision.</p>` :
                        `<p>Pendant longtemps, nous pensions que les emplois manuels étaient sûrs. "L'IA ne peut pas réparer un tuyau", disions-nous.</p>
                        <p>Nous avions tort. À la fin des années 2030, la robotique humanoïde a résolu les problèmes de batterie et de moteur. Combinés au "Cerveau" de l'IA avancée, les robots pouvaient apprendre des tâches physiques.</p>
                        <p>C'était le tournant. L'automatisation a quitté l'écran pour entrer dans l'usine et le chantier.</p>
                        <p><strong>Simulation :</strong> Le bras robotique. Augmentez la <em>Dextérité</em> pour le voir égaler la vitesse et la précision humaines.</p>`,
                    simId: "ROBOTICS",
                    controls: `<label>${translations[lang].controls.dexterity} <span id="val1">Clumsy</span></label><input type="range" min="0" max="100" value="10" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2042",
                    year: "2042",
                    title: isEn ? "The Infrastructure Build-Out" : "Le Déploiement de l'Infrastructure",
                    subtitle: isEn ? "AI builds its own body" : "L'IA construit son propre corps",
                    text: isEn ?
                        `<p>AI didn't just optimize code; it optimized the physical world. It built the factories, the mines, and the power grids needed to sustain itself and humanity.</p>
                        <p>The logic was simple: Solar was the only energy source that scaled indefinitely with zero marginal cost. The machines carpeted the deserts, not for profit, but for efficiency.</p>
                        <p>This was the "Energy Zero" event. Suddenly, the cost to run a factory, desalinate water, or smelt steel became negligible. The only limit was raw materials.</p>
                        <p><strong>Simulation:</strong> Infrastructure Growth. Watch the AI construct a self-sustaining energy grid. Increase <em>Construction Speed</em> to see the network expand.</p>` :
                        `<p>L'IA n'a pas seulement optimisé le code ; elle a optimisé le monde physique. Elle a construit les usines, les mines et les réseaux électriques.</p>
                        <p>La logique était simple : le solaire était la seule source d'énergie évolutive à coût marginal nul. Les machines ont tapissé les déserts par souci d'efficacité.</p>
                        <p>C'était l'événement "Zéro Énergétique". Soudain, le coût de l'énergie est devenu négligeable.</p>
                        <p><strong>Simulation :</strong> Croissance de l'infrastructure. Regardez l'IA construire un réseau énergétique autonome. Augmentez la <em>Vitesse de Construction</em> pour voir le réseau s'étendre.</p>`,
                    simId: "ENERGY",
                    controls: `<label>${translations[lang].controls.solar || "Construction Speed"} <span id="val1">Low</span></label><input type="range" min="0" max="100" value="10" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2045-2050",
                    title: isEn ? "The Golden Twilight" : "Le Crépuscule Doré",
                    subtitle: isEn ? "The Boom before the Bust" : "Le Boom avant le Krach",
                    text: isEn ?
                        `<p>This decade is often misunderstood. It wasn't a depression; it was a <strong>Boom</strong>.</p>
                        <p>With robots working 24/7 for pennies, the cost of goods plummeted. TVs, cars, and houses became cheaper to build. Corporate profits hit all-time highs.</p>
                        <p>Unemployment rose to 15%, but people survived on "Gig" work and cheap prices. We called it the "Golden Twilight" because everything looked shiny, but the sun was setting on the wage-labor system.</p>
                        <p><strong>Simulation:</strong> Observe the "GDP" (Yellow Line) vs "Median Wage" (Green Line). Increase automation to see GDP soar while wages stagnate.</p>` :
                        `<p>Cette décennie est souvent mal comprise. Ce n'était pas une dépression ; c'était un <strong>Boom</strong>.</p>
                        <p>Avec des robots travaillant 24/7 pour des centimes, le coût des biens a chuté. Les profits des entreprises ont atteint des sommets.</p>
                        <p>Le chômage a augmenté, mais les gens survivaient grâce à l'économie des "petits boulots". Nous l'avons appelé le "Crépuscule Doré".</p>
                        <p><strong>Simulation :</strong> Observez le "PIB" (Ligne Jaune) vs "Salaire Médian" (Ligne Verte). Augmentez l'automatisation pour voir le PIB monter en flèche tandis que les salaires stagnent.</p>`,
                    simId: "BOOM",
                    controls: `<label>${translations[lang].controls.auto} <span id="val1">Low</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2050-2055",
                    title: isEn ? "The Squeeze" : "L'Étau",
                    subtitle: isEn ? "The math breaks down" : "Les mathématiques s'effondrent",
                    text: isEn ?
                        `<p>By 2050, the trend became undeniable. Human labor was no longer competitive. Why hire a human for $20/hour when a bot does it for $0.05/hour?</p>
                        <p>Wages began to actively shrink. People took 2nd and 3rd jobs to compete. The "Gig Economy" became the "Desperation Economy."</p>
                        <p>Crucially, debt began to default. People couldn't pay mortgages. The cracks in the foundation were visible to everyone.</p>
                        <p><strong>Simulation:</strong> The Worker Pool. As you increase <em>Cost Pressure</em>, workers turn red (insolvent) and drop out of the economy.</p>` :
                        `<p>En 2050, la tendance était indéniable. Le travail humain n'était plus compétitif. Pourquoi embaucher un humain à 20$/h quand un robot le fait pour 0,05$/h ?</p>
                        <p>Les salaires ont commencé à baisser. L'économie des petits boulots est devenue l'économie du désespoir.</p>
                        <p>Les dettes ont commencé à faire défaut. Les fissures dans la fondation étaient visibles pour tous.</p>
                        <p><strong>Simulation :</strong> Le bassin de travailleurs. En augmentant la <em>Pression des Coûts</em>, les travailleurs deviennent rouges (insolvables) et sortent de l'économie.</p>`,
                    simId: "SQUEEZE",
                    controls: `<label>${translations[lang].controls.pressure} <span id="val1">Normal</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2058",
                    title: isEn ? "The Velocity Freeze" : "Le Gel de la Vélocité",
                    subtitle: isEn ? "Money stops moving" : "L'argent arrête de circuler",
                    text: isEn ?
                        `<p>An economy requires the <strong>Velocity of Money</strong>. I pay you, you pay the grocer, the grocer pays the farmer.</p>
                        <p>In 2058, this loop slowed to a crawl. Corporations had all the money, but no one to sell to. They had automated the customer out of existence.</p>
                        <p>Deflation set in. Prices dropped, but no one bought anything because they were waiting for prices to drop further, or simply had zero income.</p>
                        <p><strong>Simulation:</strong> Velocity visualization. Watch the particles (transactions) slow down as Wealth Concentration hits 99%.</p>` :
                        `<p>Une économie nécessite la <strong>Vélocité de l'Argent</strong>. Je vous paie, vous payez l'épicier, l'épicier paie le fermier.</p>
                        <p>En 2058, cette boucle a ralenti. Les entreprises avaient tout l'argent, mais personne à qui vendre. Elles avaient automatisé le client jusqu'à l'inexistence.</p>
                        <p><strong>Simulation :</strong> Visualisation de la vélocité. Regardez les particules (transactions) ralentir alors que la concentration des richesses atteint 99%.</p>`,
                    simId: "FREEZE",
                    controls: `<label>${translations[lang].controls.wealth} <span id="val1">Low</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2060",
                    title: isEn ? "THE BIG CRASH" : "LE GRAND KRACH",
                    subtitle: isEn ? "The Silent Depression" : "La Dépression Silencieuse",
                    text: isEn ?
                        `<p><strong>This is the pivot point of history.</strong></p>
                        <p>In 2060, the global supply chain halted. Warehouses were full of goods. Robots stood ready to build more. But the transaction layer ceased to exist. Unemployment hit 60%.</p>
                        <p>It wasn't a stock market crash; it was a <strong>Demand Crash</strong>. The engine of capitalism (Labor for Income for Consumption) seized up completely.</p>
                        <p><strong>Simulation:</strong> The Economy Graph. Watch Productivity (Blue) go vertical while Employment (Green) crashes. When unemployment hits 50%, the system breaks.</p>` :
                        `<p><strong>C'est le point de bascule de l'histoire.</strong></p>
                        <p>En 2060, la chaîne d'approvisionnement mondiale s'est arrêtée. Les entrepôts étaient pleins. Mais la couche transactionnelle a cessé d'exister. Le chômage a atteint 60%.</p>
                        <p>Ce n'était pas un krach boursier ; c'était un <strong>Krach de la Demande</strong>. Le moteur du capitalisme s'est grippé.</p>
                        <p><strong>Simulation :</strong> Le graphique de l'économie. Regardez la productivité (bleu) devenir verticale tandis que l'emploi (vert) s'effondre. Quand le chômage atteint 50%, le système casse.</p>`,
                    simId: "CRASH",
                    controls: `<label>${translations[lang].controls.timeline} <span id="val1">2040</span></label><input type="range" min="2040" max="2070" value="2040" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2061",
                    title: isEn ? "The Failed Stimulus" : "L'Échec du Stimulus",
                    subtitle: isEn ? "Why printing money didn't work" : "Pourquoi imprimer de l'argent n'a pas marché",
                    text: isEn ?
                        `<p>Governments panicked. They tried the old playbook: Print money and lend it to people (Stimulus/Debt).</p>
                        <p>It failed immediately. Why? Because you can only lend money to people who have jobs to pay it back. With no jobs, the credit was worthless.</p>
                        <p>The money was printed, given out, spent once on food, and immediately vacuumed back up by the automated corporations, sitting in their accounts doing nothing. The loop was broken.</p>
                        <p><strong>Simulation:</strong> Attempt to inject liquidity. Watch the water (money) pour in, but drain out instantly because there is no "Labor Floor" to hold it.</p>` :
                        `<p>Les gouvernements ont paniqué. Ils ont essayé la vieille méthode : Imprimer de l'argent et le prêter aux gens.</p>
                        <p>Cela a échoué immédiatement. On ne peut prêter de l'argent qu'à ceux qui ont un emploi pour le rembourser. Sans emploi, le crédit ne valait rien.</p>
                        <p><strong>Simulation :</strong> Tentative d'injection de liquidités. Regardez l'eau (argent) couler, mais se vider instantanément car il n'y a pas de "sol de travail" pour la retenir.</p>`,
                    simId: "STIMULUS",
                    controls: `<button class="nav-btn" style="width:100%; background:#ef4444" onclick="triggerStimulus()">${translations[lang].controls.stimulus}</button>`
                },
                {
                    year: "2062-2064",
                    title: isEn ? "The Realization" : "La Réalisation",
                    subtitle: isEn ? "No Choice Left" : "Plus le choix",
                    text: isEn ?
                        `<p>Society faced a choice: Starve amidst abundance, or change the operating system.</p>
                        <p>Economists realized that automation had turned labor into a legacy feature. The realization was simple: <strong>Money must be decoupled from Labor.</strong></p>
                        <p>If robots make the resources, we just need to distribute the tickets.</p>
                        <p><strong>Simulation:</strong> Circuit Rewiring. Connect the "Production" node directly to the "Consumption" node, bypassing the broken "Labor" switch.</p>` :
                        `<p>La société faisait face à un choix : Mourir de faim au milieu de l'abondance, ou changer le système d'exploitation.</p>
                        <p>Les économistes ont réalisé que l'automatisation avait rendu le travail obsolète. <strong>L'argent devait être découplé du Travail.</strong></p>
                        <p><strong>Simulation :</strong> Recâblage du circuit. Connectez le nœud "Production" directement au nœud "Consommation", en contournant l'interrupteur cassé du "Travail".</p>`,
                    simId: "SCALE",
                    controls: `<label>${translations[lang].controls.ideology} <span id="val1">Traditional</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2065",
                    title: isEn ? "The Dividend Compact" : "Le Pacte du Dividende",
                    subtitle: isEn ? "Deflation funds the Dividend" : "La Déflation finance le Dividende",
                    text: isEn ?
                        `<p>The math was simple: <strong>More Robots = Cheaper Goods = Negative Inflation.</strong></p>
                        <p>As AI production scaled, the cost of living collapsed. The "Automation Tax" captured this surplus value and redistributed it.</p>
                        <p>It wasn't just free money; it was the purchasing power generated by a trillion-robot workforce. The more they built, the more we received.</p>
                        <p><strong>Simulation:</strong> The Deflationary Dividend. Advance the timeline. Watch as the Robot Army grows, driving costs to zero and the Universal Dividend to the moon.</p>` :
                        `<p>Les mathématiques étaient simples : <strong>Plus de Robots = Biens Moins Chers = Inflation Négative.</strong></p>
                        <p>Alors que la production de l'IA augmentait, le coût de la vie s'effondrait. La "Taxe d'Automatisation" capturait cette plus-value et la redistribuait.</p>
                        <p>Ce n'était pas seulement de l'argent gratuit ; c'était le pouvoir d'achat généré par une main-d'œuvre de mille milliards de robots.</p>
                        <p><strong>Simulation :</strong> Le Dividende Déflationniste. Avancez la chronologie. Regardez l'Armée de Robots grandir, poussant les coûts vers zéro et le Dividende Universel vers la lune.</p>`,
                    simId: "DIVIDEND",
                    controls: `<label>${translations[lang].controls.timeline || "Timeline"} <span id="val1">2060</span></label><input type="range" min="2060" max="2100" value="2060" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2070",
                    title: isEn ? "The Purpose Crisis" : "La Crise du Sens",
                    subtitle: isEn ? "What do we do now?" : "Que fait-on maintenant ?",
                    text: isEn ?
                        `<p>Survival was solved. But a new problem emerged: Meaning.</p>
                        <p>For 5,000 years, humans defined themselves by their jobs. "I am a baker." "I am a coder." Without work, depression rates spiked.</p>
                        <p>We had to culturally reinvent ourselves. We moved from a "Production Society" to an "Exploration Society." Art, philosophy, sport, and community became the new metrics of success.</p>
                        <p><strong>Simulation:</strong> The Tree of Life. Allocate time to "Community", "Art", and "Sport" to see the tree grow. Neglect them, and it withers.</p>` :
                        `<p>La survie était résolue. Mais un nouveau problème a émergé : Le Sens.</p>
                        <p>Pendant 5000 ans, les humains se définissaient par leur travail. Sans travail, la dépression a explosé.</p>
                        <p>Nous avons dû nous réinventer culturellement. L'art, la philosophie, le sport et la communauté sont devenus les nouveaux critères de succès.</p>
                        <p><strong>Simulation :</strong> L'Arbre de Vie. Allouez du temps à la "Communauté", à "l'Art" et au "Sport" pour voir l'arbre grandir. Négligez-les, et il se flétrit.</p>`,
                    simId: "PURPOSE",
                    controls: `
                        <label>${translations[lang].controls.focus} <span id="val1">0%</span></label>
                        <input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">
                        <button class="nav-btn" style="margin-top:10px; width:100%; font-size:0.8rem" onclick="simState.seed = Date.now()">↻ New Tree Variant</button>
                    `
                },
                {
                    year: "2080",
                    title: isEn ? "The Legitimacy Economy" : "L'Économie de la Légitimité",
                    subtitle: isEn ? "Status without Wealth" : "Statut sans Richesse",
                    text: isEn ?
                        `<p>In 2080, the scarcity wasn't money—it was <strong>Trust</strong>.</p>
                        <p>With AI generating infinite content, reality became a battlefield. Narratives acted like viruses, competing for host minds in a "Darwinian War of Ideas."</p>
                        <p>To maintain Legitimacy, leaders had to balance <strong>Reach</strong> (how far the message spreads) with <strong>Stickiness</strong> (how deeply it convinces).</p>
                        <p><strong>Simulation:</strong> The Narrative War. You are the <span style="color:#06b6d4">Blue Narrative</span>. Defeat the <span style="color:#ef4444">Red Misinformation</span>. Adjust your viral parameters to win the crowd (Grey).</p>` :
                        `<p>En 2080, la rareté n'était pas l'argent, mais la <strong>Confiance</strong>.</p>
                        <p>Les récits agissaient comme des virus, s'affrontant pour les esprits dans une "Guerre Darwinienne des Idées".</p>
                        <p><strong>Simulation :</strong> La Guerre Narrative. Vous êtes le <span style="color:#06b6d4">Récit Bleu</span>. Vainquez la <span style="color:#ef4444">Désinformation Rouge</span>. Ajustez vos paramètres viraux pour gagner la foule.</p>`,
                    simId: "STATUS",
                    controls: `
                        <label>${translations[lang].controls.reach || "Viral Reach"} <span id="val1">Medium</span></label>
                        <input type="range" min="10" max="100" value="50" oninput="updateParam('p1', this.value)">
                        
                        <label>${translations[lang].controls.stickiness || "Stickiness"} <span id="val2">Medium</span></label>
                        <input type="range" min="10" max="100" value="50" oninput="updateParam('p2', this.value)">
                        
                        <button class="nav-btn" style="margin-top:10px; width:100%; font-size:0.8rem" onclick="resetStatusSim()">↻ Deploy New Narrative</button>
                    `
                },
                {
                    year: "2090",
                    title: isEn ? "Allocation of the Scarce" : "Allocation de la Rareté",
                    subtitle: isEn ? "The Universal Lottery" : "La Loterie Universelle",
                    text: isEn ?
                        `<p>In a world of post-scarcity, the only thing that remained scarce was <strong>Prime Location</strong>.</p>
                        <p>The solution was the <strong>Universal Rotation Lottery</strong>. Ownership was abolished. Instead, every citizen holds a temporary 3-year lease.</p>
                        <p>When the cycle ends, the system randomizes. You might live in a beachside villa today and a dense urban hub tomorrow. It is the ultimate equalizer.</p>
                        <p><strong>Simulation:</strong> The Lottery. Watch as the population is periodically shuffled between Housing Tiers, ensuring fair access to the best zones over time.</p>` :
                        `<p>Dans un monde de post-rareté, la seule chose qui restait rare était <strong>l'Emplacement de Choix</strong>.</p>
                        <p>La solution fut la <strong>Loterie de Rotation Universelle</strong>. La propriété a été abolie. Au lieu de cela, chaque citoyen détient un bail temporaire de 3 ans.</p>
                        <p>À la fin du cycle, le système randomise. C'est l'égaliseur ultime.</p>
                        <p><strong>Simulation :</strong> La Loterie. Regardez la population être périodiquement mélangée entre les niveaux de logement.</p>`,
                    simId: "LAND",
                    controls: "" // No controls, self-playing
                },
                {
                    year: "2100",
                    title: isEn ? "The Guardrails" : "Les Garde-fous",
                    subtitle: isEn ? "Containing the Infinite" : "Contenir l'Infini",
                    text: isEn ?
                        `<p>AI Intelligence was now billions of times greater than human intelligence. The risk wasn't economic anymore; it was existential.</p>
                        <p>Society built the "Great Guardrails." We used AI to police AI. Research was accelerated, but automated safety loops checked every discovery before implementation.</p>
                        <p>We essentially built a nuclear reactor for intelligence, carefully managed to prevent a meltdown.</p>
                        <p><strong>Simulation:</strong> The Reactor. Increase Research Speed, but keep Risk below the critical threshold using Safety Checks.</p>` :
                        `<p>L'intelligence de l'IA était maintenant des milliards de fois supérieure à l'intelligence humaine. Le risque était existentiel.</p>
                        <p>La société a construit les "Grands Garde-fous". Nous avons utilisé l'IA pour surveiller l'IA.</p>
                        <p><strong>Simulation :</strong> Le Réacteur. Augmentez la vitesse de recherche, mais gardez le risque sous le seuil critique en utilisant les contrôles de sécurité.</p>`,
                    simId: "GUARDRAILS",
                    controls: `<label>${translations[lang].controls.research} <span id="val1">Safe</span></label><input type="range" min="0" max="100" value="20" oninput="updateParam('p1', this.value)">`
                },
                {
                    year: "2150",
                    title: isEn ? "The Horizon" : "L'Horizon",
                    subtitle: isEn ? "To the Stars" : "Vers les Étoiles",
                    text: isEn ?
                        `<p>Here we are, in 2150.</p>
                        <p>We have decoupled survival from labor. We have stabilized the social structure. We have unlimited intelligence and energy.</p>
                        <p>The only frontier left is outwards. The surplus energy of humanity is now directed at Mars, Europa, and Alpha Centauri. We are no longer laborers; we are explorers.</p>
                        <p><strong>Simulation:</strong> The Departure. Initiate the launch sequence to witness humanity's next step.</p>` :
                        `<p>Nous y sommes, en 2150.</p>
                        <p>Nous avons découplé la survie du travail. Nous avons une intelligence et une énergie illimitées.</p>
                        <p>La seule frontière restante est vers l'extérieur. Nous ne sommes plus des travailleurs ; nous sommes des explorateurs.</p>
                        <p><strong>Simulation :</strong> Le Départ. Lancez la séquence de lancement pour assister à la prochaine étape de l'humanité.</p>`,
                    simId: "SPACE",
                    controls: `<button class="nav-btn" style="width:100%; background:var(--accent-cyan); padding: 15px; font-weight:bold; letter-spacing:2px;" onclick="triggerLaunch()">${translations[lang].controls.launch}</button>`
                }
            ];
        }

        /**
         * --- APP STATE & INIT ---
         */
        let chapters = [];
        let currentChapterIdx = 0;
        let simParams = { p1: 0, p2: 0 };
        let canvas, ctx;
        let animationFrame;
        let simState = {};

        function selectLang(lang, btn) {
            currentLang = lang;
            document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');

            // Update Intro Text
            const t = translations[lang].intro;
            document.querySelector('.intro-subtitle').innerText = t.subtitle;
            document.querySelector('#introText').innerHTML = t.text;
            document.querySelector('#enterBtn').innerText = t.enter;

            // Show Enter Button
            document.querySelector('#enterBtn').classList.add('visible');
        }

        function startExperience() {
            document.getElementById('introOverlay').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('introOverlay').style.display = 'none';
                init();
            }, 1000);
        }

        // Canvas Helpers
        function resizeCanvas() {
            if (!canvas) return;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        function init() {
            canvas = document.getElementById('simCanvas');
            ctx = canvas.getContext('2d');

            // Load Data
            chapters = getChapters(currentLang);

            // Populate Sidebar
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = ''; // Clear existing
            chapters.forEach((chap, i) => {
                const div = document.createElement('div');
                div.className = `timeline-item ${i === 0 ? 'active' : ''}`;
                div.innerHTML = `<div class="t-year">${chap.year}</div><div class="t-title">${chap.title}</div>`;
                div.onclick = () => loadChapter(i);
                sidebar.appendChild(div);
            });

            window.addEventListener('resize', resizeCanvas);
            loadChapter(0);
        }

        /**
         * --- CORE LOGIC ---
         */
        function loadChapter(index) {
            currentChapterIdx = index;
            simParams = { p1: 0, p2: 0 }; // Reset params
            simState = {}; // Reset sim state for new chapter

            // UI Updates
            const chap = chapters[index];
            const sidebarItems = document.querySelectorAll('.timeline-item');
            sidebarItems.forEach((item, i) => {
                item.className = `timeline-item ${i === index ? 'active' : ''}`;
                if (i === index) item.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });

            // Narrative Update
            const narrative = document.getElementById('narrativeContent');
            narrative.innerHTML = `
                <h2>${chap.year} // ${chap.subtitle}</h2>
                <h1>${chap.title}</h1>
                ${chap.text}
                <div style="margin-top:40px; display:flex; gap:10px;">
                    <button class="nav-btn" onclick="prev()" ${index === 0 ? 'disabled' : ''}>${translations[currentLang].back}</button>
                    <button class="nav-btn" onclick="next()" ${index === chapters.length - 1 ? 'disabled' : ''}>${translations[currentLang].next}</button>
                </div>
            `;

            // Controls Update
            const controls = document.getElementById('simControls');
            controls.innerHTML = chap.controls;

            // Initialize default params from controls if present
            const inputs = controls.querySelectorAll('input');
            inputs.forEach(input => {
                if (input.oninput) {
                    // Extract param name from oninput string (hacky but works for this structure)
                    // oninput="updateParam('p1', this.value)"
                    const match = input.getAttribute('oninput').match(/'(p\d)'/);
                    if (match) {
                        simParams[match[1]] = parseFloat(input.value);
                        updateParam(match[1], input.value);
                    }
                }
            });

            // Start Animation Loop
            if (animationFrame) cancelAnimationFrame(animationFrame);
            resizeCanvas();
            renderLoop();
        }

        function updateParam(key, value) {
            simParams[key] = parseFloat(value);
            const labelSpan = document.getElementById(key === 'p1' ? 'val1' : 'val2');
            if (labelSpan) {
                const id = chapters[currentChapterIdx].simId;
                if (id === "CRASH") labelSpan.innerText = value;
                else if (id === "LAND" || id === "STATUS") labelSpan.innerText = ""; // No text update needed
                else if (id === "SPACE") labelSpan.innerText = value + (key === 'p2' ? "°" : "%");
                else labelSpan.innerText = value + (id === "GUARDRAILS" ? "" : "%");
            }
        }

        function next() { if (currentChapterIdx < chapters.length - 1) loadChapter(currentChapterIdx + 1); }
        function prev() { if (currentChapterIdx > 0) loadChapter(currentChapterIdx - 1); }

        /**
         * --- VISUALIZATION ENGINE ---
         */
        function renderLoop() {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            const id = chapters[currentChapterIdx].simId;
            const time = Date.now() * 0.001;

            switch (id) {
                case "SPARK": renderSpark(w, h, time); break;
                case "AGENTS": renderAgents(w, h, time); break;
                case "ROBOTICS": renderRobotics(w, h, time); break;
                case "ENERGY": renderEnergy(w, h, time); break;
                case "BOOM": renderBoom(w, h, time); break;
                case "SQUEEZE": renderSqueeze(w, h, time); break;
                case "FREEZE": renderFreeze(w, h, time); break;
                case "CRASH": renderCrash(w, h, time); break;
                case "STIMULUS": renderStimulus(w, h, time); break;
                case "SCALE": renderScale(w, h, time); break;
                case "DIVIDEND": renderDividend(w, h, time); break;
                case "PURPOSE": renderPurpose(w, h, time); break;
                case "STATUS": renderStatus(w, h, time); break;
                case "LAND": renderLand(w, h, time); break;
                case "GUARDRAILS": renderGuardrails(w, h, time); break;
                case "SPACE": renderSpace(w, h, time); break;
            }

            animationFrame = requestAnimationFrame(renderLoop);
        }

        // --- SIMULATIONS ---

        function renderSpark(w, h, t) {
            const density = simParams.p1; // 0 to 100
            const nodeCount = Math.floor(20 + (density / 100) * 80); // 20 to 100 nodes
            const connectDist = 150;

            // Initialize Pool
            if (!simState.nodes || simState.nodes.length !== 100) {
                simState.nodes = Array.from({ length: 100 }, () => ({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 0.8,
                    vy: (Math.random() - 0.5) * 0.8,
                    size: 1.5 + Math.random() * 2,
                    phase: Math.random() * Math.PI * 2
                }));
                simState.pulses = [];
            }

            // Update Nodes
            simState.nodes.forEach(n => {
                n.x += n.vx;
                n.y += n.vy;

                // Wrap
                if (n.x < -50) n.x = w + 50;
                if (n.x > w + 50) n.x = -50;
                if (n.y < -50) n.y = h + 50;
                if (n.y > h + 50) n.y = -50;

                // Pulse Size
                n.currentSize = n.size + Math.sin(t * 2 + n.phase) * 0.5;
            });

            // Draw Connections & Pulses
            ctx.lineWidth = 1.5;
            for (let i = 0; i < nodeCount; i++) {
                const n1 = simState.nodes[i];
                for (let j = i + 1; j < nodeCount; j++) {
                    const n2 = simState.nodes[j];
                    const dx = n1.x - n2.x;
                    const dy = n1.y - n2.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < connectDist) {
                        // Line
                        const alpha = (1 - dist / connectDist);
                        ctx.strokeStyle = `rgba(6, 182, 212, ${alpha * 0.5})`;
                        ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y); ctx.stroke();

                        // Spawn Pulse
                        if (Math.random() < 0.0005 * density) {
                            simState.pulses.push({
                                from: n1,
                                to: n2,
                                p: 0,
                                speed: 0.02 + Math.random() * 0.03,
                                life: 1
                            });
                        }
                    }
                }
            }

            // Draw Pulses
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 6;
            simState.pulses.forEach((p, i) => {
                p.p += p.speed;
                if (p.p >= 1) { p.life = 0; return; }

                const x = p.from.x + (p.to.x - p.from.x) * p.p;
                const y = p.from.y + (p.to.y - p.from.y) * p.p;

                ctx.globalAlpha = p.life;
                ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            });
            simState.pulses = simState.pulses.filter(p => p.life > 0);
            ctx.shadowBlur = 0;

            // Draw Nodes
            for (let i = 0; i < nodeCount; i++) {
                const n = simState.nodes[i];
                ctx.fillStyle = '#06b6d4';
                ctx.shadowColor = '#06b6d4';
                ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.arc(n.x, n.y, n.currentSize, 0, Math.PI * 2); ctx.fill();
            }
            ctx.shadowBlur = 0;
        }

        function renderAgents(w, h, t) {
            const aiLevel = simParams.p1;
            const numAgents = Math.floor(aiLevel / 1.5);
            const numHumans = 40;

            if (!simState.agents) {
                simState.agents = [];
                // Humans
                for (let i = 0; i < numHumans; i++) {
                    simState.agents.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() - 0.5), vy: (Math.random() - 0.5), type: 'human' });
                }
                // AI (Pool)
                for (let i = 0; i < 100; i++) {
                    simState.agents.push({ x: Math.random() * w, y: Math.random() * h, vx: 0, vy: 0, type: 'ai', active: false });
                }
            }

            // Activate AI based on slider
            simState.agents.forEach((a, i) => {
                if (a.type === 'ai') a.active = i < (numHumans + numAgents);
            });

            // Tasks
            if (!simState.tasks) simState.tasks = [];
            if (Math.random() < 0.05) simState.tasks.push({ x: Math.random() * w, y: Math.random() * h, life: 150 });

            // Boids / Swarm Logic
            simState.agents.forEach(a => {
                if (a.type === 'ai' && !a.active) return;

                // Physics
                a.x += a.vx; a.y += a.vy;
                if (a.x < 0 || a.x > w) a.vx *= -1;
                if (a.y < 0 || a.y > h) a.vy *= -1;

                // Behavior
                if (a.type === 'ai') {
                    // Seek Task
                    if (simState.tasks.length > 0) {
                        let closest = null;
                        let minDist = Infinity;
                        simState.tasks.forEach(task => {
                            const d = (task.x - a.x) ** 2 + (task.y - a.y) ** 2;
                            if (d < minDist) { minDist = d; closest = task; }
                        });

                        if (closest) {
                            const angle = Math.atan2(closest.y - a.y, closest.x - a.x);
                            a.vx += Math.cos(angle) * 0.5;
                            a.vy += Math.sin(angle) * 0.5;
                        }
                    }
                    // Friction
                    a.vx *= 0.95; a.vy *= 0.95;

                    ctx.fillStyle = '#06b6d4';
                    ctx.beginPath();
                    ctx.moveTo(a.x + a.vx * 2, a.y + a.vy * 2);
                    ctx.lineTo(a.x - 5, a.y - 5);
                    ctx.lineTo(a.x - 5, a.y + 5);
                    ctx.fill();
                } else {
                    // Human - Browninan
                    a.vx += (Math.random() - 0.5) * 0.2;
                    a.vy += (Math.random() - 0.5) * 0.2;
                    a.vx = Math.max(-2, Math.min(2, a.vx));
                    a.vy = Math.max(-2, Math.min(2, a.vy));

                    ctx.fillStyle = '#10b981';
                    ctx.beginPath(); ctx.arc(a.x, a.y, 4, 0, Math.PI * 2); ctx.fill();
                }
            });

            // Tasks
            simState.tasks.forEach((task, i) => {
                task.life--;
                ctx.strokeStyle = `rgba(255, 255, 255, ${task.life / 150})`;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(task.x, task.y, 8, 0, Math.PI * 2); ctx.stroke();

                // Collision
                simState.agents.forEach(a => {
                    if (a.type === 'ai' && a.active) {
                        if ((a.x - task.x) ** 2 + (a.y - task.y) ** 2 < 400) {
                            task.life = 0;
                            // Particle burst
                            ctx.fillStyle = '#fff';
                            ctx.beginPath(); ctx.arc(task.x, task.y, 15, 0, Math.PI * 2); ctx.fill();
                        }
                    }
                });
            });
            simState.tasks = simState.tasks.filter(t => t.life > 0);
        }

        function renderRobotics(w, h, t) {
            const precision = simParams.p1; // 0 to 100
            const cx = w / 2;
            const cy = h / 2 + 100; // Moved up significantly

            // Initialize State
            if (!simState.robot) {
                simState.robot = {
                    state: 'IDLE', // IDLE, MOVE_TO_PICK, GRAB, MOVE_TO_DROP, DROP
                    target: { x: cx, y: cy - 200 },
                    current: { x: cx, y: cy - 200 },
                    heldBall: null,
                    timer: 0,
                    balls: [], // Balls in the air/bowls
                    score: 0
                };
                // Pre-fill source bowl
                for (let i = 0; i < 5; i++) {
                    simState.robot.balls.push({
                        x: cx - 150 + (Math.random() - 0.5) * 40,
                        y: cy - 20 - Math.random() * 30,
                        vx: 0, vy: 0,
                        state: 'SOURCE' // SOURCE, HELD, DROPPED, DEST
                    });
                }
            }

            const robot = simState.robot;
            const speed = 0.05 + (precision / 100) * 0.15; // Speed based on precision
            const jitterAmt = Math.max(0, (100 - precision) * 0.8); // More jitter

            // Bowl Positions
            const sourcePos = { x: cx - 150, y: cy - 50 };
            const destPos = { x: cx + 150, y: cy - 50 };

            // --- LOGIC ---

            // State Machine
            switch (robot.state) {
                case 'IDLE':
                    robot.state = 'MOVE_TO_PICK';
                    // Find a ball in source
                    const targetBall = robot.balls.find(b => b.state === 'SOURCE');
                    if (targetBall) {
                        robot.target = { x: targetBall.x, y: targetBall.y - 10 };
                    } else {
                        // Spawn new ball if empty
                        robot.balls.push({ x: sourcePos.x, y: sourcePos.y - 100, vx: 0, vy: 0, state: 'SOURCE' });
                        robot.state = 'IDLE'; // Wait for it to fall
                    }
                    break;

                case 'MOVE_TO_PICK':
                    if (dist(robot.current, robot.target) < 15) {
                        robot.state = 'GRAB';
                        robot.timer = 0;
                    }
                    break;

                case 'GRAB':
                    robot.timer++;
                    if (robot.timer > 10) {
                        // Grab closest ball
                        const ball = robot.balls.find(b => b.state === 'SOURCE' && dist(b, robot.current) < 40);

                        // Failure chance: Miss the grab
                        const fumbleChance = (100 - precision) * 0.005; // Up to 50% chance to miss at 0 precision

                        if (ball && Math.random() > fumbleChance) {
                            ball.state = 'HELD';
                            robot.heldBall = ball;
                            robot.state = 'MOVE_TO_DROP';
                            robot.target = { x: destPos.x, y: destPos.y - 100 };
                        } else {
                            // Missed or fumbled
                            robot.state = 'IDLE';
                            // If we missed but there was a ball, maybe knock it
                            if (ball) {
                                ball.vx = (Math.random() - 0.5) * 5;
                                ball.vy = -2;
                            }
                        }
                    }
                    break;

                case 'MOVE_TO_DROP':
                    if (dist(robot.current, robot.target) < 15) {
                        robot.state = 'DROP';
                        robot.timer = 0;
                    }
                    // Chance to drop mid-air (Higher failure rate)
                    // At 0 precision, ~2% chance per frame to drop
                    if (robot.heldBall && Math.random() < (100 - precision) * 0.002) {
                        robot.heldBall.state = 'DROPPED';
                        robot.heldBall.vx = (Math.random() - 0.5) * 5;
                        robot.heldBall.vy = -2;
                        robot.heldBall = null;
                        robot.state = 'IDLE'; // Reset
                    }
                    break;

                case 'DROP':
                    robot.timer++;
                    if (robot.timer > 10) {
                        if (robot.heldBall) {
                            robot.heldBall.state = 'DEST';
                            robot.heldBall.vx = (Math.random() - 0.5) * 2;
                            robot.heldBall.vy = 2;
                            robot.heldBall = null;
                            robot.score++;
                        }
                        robot.state = 'IDLE';
                    }
                    break;
            }

            // Move Arm towards Target (Smooth Lerp)
            // Add jitter to target
            const noisyTarget = {
                x: robot.target.x + (Math.random() - 0.5) * jitterAmt,
                y: robot.target.y + (Math.random() - 0.5) * jitterAmt
            };

            robot.current.x += (noisyTarget.x - robot.current.x) * speed;
            robot.current.y += (noisyTarget.y - robot.current.y) * speed;

            // --- PHYSICS (Balls) ---
            robot.balls.forEach(b => {
                if (b.state === 'HELD') {
                    b.x = robot.current.x;
                    b.y = robot.current.y + 10;
                    b.vx = 0; b.vy = 0;
                } else {
                    // Gravity
                    b.vy += 0.5;
                    b.x += b.vx;
                    b.y += b.vy;
                    b.vx *= 0.95; // Air resistance

                    // Floor / Bowl Collisions
                    // Source Bowl
                    if (b.x > sourcePos.x - 40 && b.x < sourcePos.x + 40 && b.y > sourcePos.y) {
                        b.y = sourcePos.y;
                        b.vy *= -0.5;
                        b.vx *= 0.8;
                        // Keep in bowl
                        if (b.x < sourcePos.x - 30) b.vx += 1;
                        if (b.x > sourcePos.x + 30) b.vx -= 1;
                    }
                    // Dest Bowl
                    if (b.x > destPos.x - 40 && b.x < destPos.x + 40 && b.y > destPos.y) {
                        b.y = destPos.y;
                        b.vy *= -0.5;
                        b.vx *= 0.8;
                        if (b.x < destPos.x - 30) b.vx += 1;
                        if (b.x > destPos.x + 30) b.vx -= 1;
                    }
                    // Floor
                    if (b.y > h - 20) {
                        b.y = h - 20;
                        b.vy *= -0.6;
                        b.vx *= 0.8;
                    }
                }
            });

            // Cleanup fallen balls
            if (robot.balls.length > 15) robot.balls.shift();


            // --- RENDER ---

            // Draw Bowls
            ctx.fillStyle = '#333';
            // Source
            ctx.beginPath(); ctx.arc(sourcePos.x, sourcePos.y, 40, 0, Math.PI, false); ctx.fill();
            // Dest
            ctx.beginPath(); ctx.arc(destPos.x, destPos.y, 40, 0, Math.PI, false); ctx.fill();

            // Draw Balls
            robot.balls.forEach(b => {
                ctx.fillStyle = b.state === 'DEST' ? '#10b981' : (b.state === 'HELD' ? '#fff' : '#f59e0b');
                ctx.beginPath(); ctx.arc(b.x, b.y, 8, 0, Math.PI * 2); ctx.fill();
            });

            // Inverse Kinematics for Arm
            const L1 = 180;
            const L2 = 160;
            const dx = robot.current.x - cx;
            const dy = robot.current.y - cy;
            const distToTarget = Math.sqrt(dx * dx + dy * dy);
            const clampedDist = Math.min(distToTarget, L1 + L2 - 1);

            const a1 = Math.atan2(dy, dx);
            const a2 = Math.acos((L1 * L1 + clampedDist * clampedDist - L2 * L2) / (2 * L1 * clampedDist));

            const angle1 = a1 - a2;
            const j1x = cx + Math.cos(angle1) * L1;
            const j1y = cy + Math.sin(angle1) * L1;

            // Draw Arm
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Base
            ctx.fillStyle = '#444';
            ctx.fillRect(cx - 20, cy - 10, 40, 20);

            // Segment 1
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 16;
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(j1x, j1y); ctx.stroke();

            // Segment 2
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 12;
            ctx.beginPath(); ctx.moveTo(j1x, j1y); ctx.lineTo(robot.current.x, robot.current.y); ctx.stroke();

            // Joints
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(j1x, j1y, 8, 0, Math.PI * 2); ctx.fill();

            // Gripper
            ctx.fillStyle = '#ef4444';
            ctx.beginPath(); ctx.arc(robot.current.x, robot.current.y, 10, 0, Math.PI * 2); ctx.fill();

            // Helper func
            function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
        }

        function renderEnergy(w, h, t) {
            const speed = simParams.p1; // 0 to 100
            const cx = w / 2;
            const cy = h / 2;

            // Initialize State
            if (!simState.energy) {
                simState.energy = {
                    nodes: [{ x: cx, y: cy, q: 0, r: 0 }], // Axial coordinates for Hex
                    drones: [],
                    sparks: [],
                    pulses: [],
                    hexSize: 25,
                    lastSpawn: 0
                };
                // Spawn initial drone swarm
                for (let i = 0; i < 20; i++) {
                    simState.energy.drones.push({
                        x: cx + (Math.random() - 0.5) * 100,
                        y: cy + (Math.random() - 0.5) * 100,
                        vx: 0, vy: 0,
                        state: 'IDLE',
                        target: null
                    });
                }
            }
            const state = simState.energy;
            const hexSize = state.hexSize;

            // --- LOGIC ---

            // 1. Drone Management (Spawn & Assign)
            // Maintain drone count based on slider
            const targetDrones = 20 + Math.floor(speed);
            if (state.drones.length < targetDrones && Math.random() < 0.1) {
                state.drones.push({ x: cx, y: cy, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, state: 'IDLE' });
            }

            // Assign Tasks
            state.drones.forEach(d => {
                if (d.state === 'IDLE') {
                    // Orbit behavior
                    const dx = d.x - cx;
                    const dy = d.y - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) + 0.05; // Orbit
                    const targetDist = 100 + Math.sin(t * 2) * 50;

                    d.vx += (Math.cos(angle) * targetDist - dx) * 0.01;
                    d.vy += (Math.sin(angle) * targetDist - dy) * 0.01;

                    // Chance to build if we have speed
                    if (Math.random() < (speed / 5000)) {
                        // Find a spot
                        const parent = state.nodes[Math.floor(Math.random() * state.nodes.length)];
                        // Hex neighbors (axial)
                        const neighbors = [
                            { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
                            { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
                        ];
                        const dir = neighbors[Math.floor(Math.random() * 6)];
                        const nq = parent.q + dir.q;
                        const nr = parent.r + dir.r;

                        // Check if exists
                        const exists = state.nodes.some(n => n.q === nq && n.r === nr);
                        if (!exists) {
                            // Calc pixel pos
                            const nx = cx + hexSize * (3 / 2 * nq);
                            const ny = cy + hexSize * (Math.sqrt(3) / 2 * nq + Math.sqrt(3) * nr);

                            // Check bounds
                            if (nx > 50 && nx < w - 50 && ny > 50 && ny < h - 50) {
                                d.state = 'BUILD';
                                d.target = { x: nx, y: ny, q: nq, r: nr };
                            }
                        }
                    }
                } else if (d.state === 'BUILD') {
                    // Fly to target
                    const dx = d.target.x - d.x;
                    const dy = d.target.y - d.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 5) {
                        // Build!
                        state.nodes.push({ x: d.target.x, y: d.target.y, q: d.target.q, r: d.target.r });
                        d.state = 'IDLE';

                        // Sparks
                        for (let i = 0; i < 8; i++) {
                            state.sparks.push({
                                x: d.target.x, y: d.target.y,
                                vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                                life: 20
                            });
                        }

                        // Pulse back to center
                        state.pulses.push({
                            x: d.target.x, y: d.target.y,
                            tx: cx, ty: cy,
                            life: 1
                        });

                    } else {
                        d.vx += dx * 0.05;
                        d.vy += dy * 0.05;
                    }
                }

                // Physics
                d.x += d.vx;
                d.y += d.vy;
                d.vx *= 0.9;
                d.vy *= 0.9;
            });

            // 2. Energy Pulses (Flow from nodes to center)
            if (Math.random() < 0.1) {
                const start = state.nodes[Math.floor(Math.random() * state.nodes.length)];
                state.pulses.push({ x: start.x, y: start.y, tx: cx, ty: cy, life: 1 });
            }

            // Reset if too big
            if (state.nodes.length > 400) {
                state.nodes = [{ x: cx, y: cy, q: 0, r: 0 }];
                state.sparks = [];
            }

            // --- RENDER ---

            // Draw Connections (Hex Grid)
            ctx.strokeStyle = 'rgba(6, 182, 212, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            state.nodes.forEach(n => {
                // Connect to neighbors
                // Simple distance check is faster than hex math for drawing
                state.nodes.forEach(n2 => {
                    const d = Math.hypot(n.x - n2.x, n.y - n2.y);
                    if (d < hexSize * 2.1 && d > 1) {
                        ctx.moveTo(n.x, n.y);
                        ctx.lineTo(n2.x, n2.y);
                    }
                });
            });
            ctx.stroke();

            // Draw Pulses
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#f59e0b';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            state.pulses.forEach(p => {
                p.x += (p.tx - p.x) * 0.1;
                p.y += (p.ty - p.y) * 0.1;
                if (Math.hypot(p.x - p.tx, p.y - p.ty) < 5) p.life = 0;

                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x - (p.tx - p.x) * 0.2, p.y - (p.ty - p.y) * 0.2); // Trail
            });
            ctx.stroke();
            state.pulses = state.pulses.filter(p => p.life > 0);
            ctx.shadowBlur = 0;

            // Draw Nodes (Solar Panels)
            state.nodes.forEach(n => {
                ctx.fillStyle = '#0f172a';
                ctx.strokeStyle = '#06b6d4';
                ctx.lineWidth = 1;

                // Hexagon shape
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = 2 * Math.PI / 6 * i;
                    const x_i = n.x + hexSize * 0.8 * Math.cos(angle);
                    const y_i = n.y + hexSize * 0.8 * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x_i, y_i); else ctx.lineTo(x_i, y_i);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Inner glow
                ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                ctx.fill();
            });

            // Draw Drones
            state.drones.forEach(d => {
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 5;
                ctx.beginPath(); ctx.arc(d.x, d.y, 2, 0, Math.PI * 2); ctx.fill();
                // Thruster trail
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.beginPath(); ctx.moveTo(d.x, d.y); ctx.lineTo(d.x - d.vx * 2, d.y - d.vy * 2); ctx.stroke();
            });
            ctx.shadowBlur = 0;

            // Draw Sparks
            ctx.fillStyle = '#f59e0b';
            state.sparks.forEach(s => {
                s.x += s.vx; s.y += s.vy; s.life--;
                ctx.globalAlpha = s.life / 20;
                ctx.beginPath(); ctx.arc(s.x, s.y, 1, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;
            state.sparks = state.sparks.filter(s => s.life > 0);

            // Stats
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(20, h - 70, 320, 50);
            ctx.fillStyle = '#06b6d4';
            ctx.font = 'bold 16px monospace';
            ctx.fillText(`GRID CAPACITY: ${(state.nodes.length * 1.2).toFixed(1)} GW`, 30, h - 45);
            ctx.fillStyle = '#f59e0b';
            ctx.font = '12px monospace';
            ctx.fillText(`ACTIVE DRONES: ${state.drones.length}`, 30, h - 25);
        }

        function renderBoom(w, h, t) {
            const auto = simParams.p1;
            const graphH = h * 0.6;
            const graphY = 50;

            // Grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(50, graphY + graphH); ctx.lineTo(w - 50, graphY + graphH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(50, graphY + graphH); ctx.lineTo(50, graphY); ctx.stroke();

            // GDP (Yellow)
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#f59e0b';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(50, graphY + graphH);
            for (let x = 50; x < w - 50; x += 5) {
                const progress = (x - 50) / (w - 100);
                const y = (graphY + graphH) - (progress * progress * 200) - (progress * auto * 2.5);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Wages (Green)
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#10b981';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(50, graphY + graphH);
            for (let x = 50; x < w - 50; x += 5) {
                const progress = (x - 50) / (w - 100);
                let y = (graphY + graphH) - (progress * 100);
                if (progress > 0.6) y += (progress - 0.6) * 50 * (auto / 50);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 16px sans-serif'; ctx.fillText("GDP (Corporate Profits)", w - 250, graphY + graphH - 220);
            ctx.fillStyle = '#10b981'; ctx.fillText("Median Wage", w - 250, graphY + graphH - 60);
        }

        function renderSqueeze(w, h, t) {
            const pressure = simParams.p1; // 0 to 100

            if (!simState.workers) {
                simState.workers = [];
                for (let i = 0; i < 100; i++) {
                    simState.workers.push({
                        x: Math.random() * w,
                        y: Math.random() * (h - 150),
                        vy: 0,
                        solvent: true,
                        r: 4 + Math.random() * 4
                    });
                }
            }

            simState.workers.forEach((p, i) => {
                // Insolvency check
                const threshold = (100 - pressure) / 100;
                const resilience = (i / 100);
                p.solvent = resilience < threshold;

                if (!p.solvent) {
                    p.vy += 0.2; // Gravity
                    p.y += p.vy;
                } else {
                    p.y += Math.sin(t + i) * 0.2; // Float
                    p.vy = 0;
                }

                ctx.fillStyle = p.solvent ? '#10b981' : '#ef4444';
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
            });

            // "The Floor"
            ctx.fillStyle = '#ef4444';
            ctx.globalAlpha = 0.2;
            ctx.fillRect(0, h, w, -50);
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText("INSOLVENCY ZONE", w / 2, h - 20);
        }

        function renderFreeze(w, h, t) {
            const concentration = simParams.p1;
            const particleCount = 100;
            if (!simState.freeze) {
                simState.freeze = Array.from({ length: particleCount }, () => ({
                    x: Math.random() * w, y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8
                }));
            }

            const speedMod = Math.max(0.00, 1 - (concentration / 95)); // Stops completely at high wealth

            simState.freeze.forEach(p => {
                p.x += p.vx * speedMod;
                p.y += p.vy * speedMod;
                if (p.x < 0 || p.x > w) p.vx *= -1;
                if (p.y < 0 || p.y > h) p.vy *= -1;

                const speed = Math.hypot(p.vx * speedMod, p.vy * speedMod);
                const color = speed < 0.1 ? '#555' : '#10b981';

                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
            });

            // Black Hole of Wealth
            const r = (concentration / 100) * 150;
            ctx.fillStyle = 'rgba(245, 158, 11, 0.2)';
            ctx.beginPath(); ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#f59e0b';
            ctx.beginPath(); ctx.arc(w / 2, h / 2, r, 0, Math.PI * 2); ctx.stroke();

            if (concentration > 90) {
                ctx.fillStyle = '#ef4444';
                ctx.font = '30px monospace';
                ctx.textAlign = 'center';
                ctx.fillText("VELOCITY: ZERO", w / 2, h / 2);
            }
        }

        function renderCrash(w, h, t) {
            const year = simParams.p1;
            const progress = (year - 2040) / 30;
            const isCrash = year >= 2060;

            // Screen Shake
            let sx = 0, sy = 0;
            if (isCrash) {
                sx = (Math.random() - 0.5) * 10;
                sy = (Math.random() - 0.5) * 10;
            }
            ctx.save();
            ctx.translate(sx, sy);

            // Background Warning
            if (isCrash) {
                ctx.fillStyle = `rgba(239, 68, 68, ${0.1 + Math.sin(t * 10) * 0.05})`;
                ctx.fillRect(0, 0, w, h);

                // Binary Rain
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.font = '14px monospace';
                for (let i = 0; i < 20; i++) {
                    ctx.fillText(Math.random() > 0.5 ? '1' : '0', Math.random() * w, Math.random() * h);
                }
            }

            // Graph Layout
            const pad = 60;
            const graphW = w - pad * 2;
            const graphH = h - pad * 2;
            const originX = pad;
            const originY = h - pad;

            // Axes
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(originX + graphW, originY); ctx.stroke(); // X
            ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(originX, pad); ctx.stroke(); // Y

            // 1. Productivity (Blue - Exponential)
            ctx.strokeStyle = '#06b6d4';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#06b6d4'; ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(originX, originY - graphH * 0.2); // Start a bit up

            // Draw full curve up to current year
            for (let i = 0; i <= progress * 100; i++) {
                const p = i / 100; // 0 to progress
                const x = originX + p * graphW;
                const y = (originY - graphH * 0.2) - (p * p * graphH * 0.8);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Label
            if (progress > 0.1) {
                ctx.fillStyle = '#06b6d4';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText("PRODUCTIVITY", originX + 10, originY - graphH * 0.2 - 20);
            }

            // 2. Employment (Green -> Red Crash)
            // We draw this in two segments: Pre-2060 and Post-2060

            const crashP = (2060 - 2040) / 30; // ~0.66

            // Segment 1: Stable (Green)
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#10b981'; ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(originX, originY - graphH * 0.6); // Start high

            const endStable = Math.min(progress, crashP);
            for (let i = 0; i <= endStable * 100; i++) {
                const p = i / 100;
                const x = originX + p * graphW;
                // Slight decline before crash
                const y = (originY - graphH * 0.6) + (p * graphH * 0.1);
                ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Segment 2: The Crash (Red)
            if (progress > crashP) {
                ctx.strokeStyle = '#ef4444';
                ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 20;
                ctx.beginPath();
                // Start where green left off
                const startX = originX + crashP * graphW;
                const startY = (originY - graphH * 0.6) + (crashP * graphH * 0.1);
                ctx.moveTo(startX, startY);

                for (let i = Math.floor(crashP * 100); i <= progress * 100; i++) {
                    const p = i / 100;
                    const localP = (p - crashP) / (1 - crashP); // 0 to 1 during crash phase
                    const x = originX + p * graphW;

                    // Dramatic drop with noise
                    let y = startY + (localP * graphH * 0.8); // Drop 80% of height
                    y += (Math.random() - 0.5) * 20; // Jitter

                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Employment Label
            ctx.fillStyle = isCrash ? '#ef4444' : '#10b981';
            ctx.fillText("EMPLOYMENT", originX + 10, originY - graphH * 0.6 - 10);

            // Big Overlay Text
            if (isCrash) {
                ctx.save();
                ctx.translate(w / 2, h / 2);
                ctx.rotate(-0.1);
                ctx.fillStyle = '#ef4444';
                ctx.textAlign = 'center';
                ctx.font = '900 60px sans-serif';
                ctx.shadowColor = '#000'; ctx.shadowBlur = 20;
                ctx.fillText("SYSTEM FAILURE", 0, 0);

                ctx.font = '20px monospace';
                ctx.fillStyle = '#fff';
                ctx.fillText("DEMAND COLLAPSE // UNEMPLOYMENT > 60%", 0, 40);
                ctx.restore();

                // Binary Rain
                ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.font = '12px monospace';
                for (let i = 0; i < 20; i++) {
                    ctx.fillText(Math.random() > 0.5 ? "1" : "0", Math.random() * w, Math.random() * h);
                }
            }

            ctx.restore();
        }

        function renderStimulus(w, h, t) {
            const cx = w / 2;
            const cy = h / 2;
            const bucketW = 200;
            const bucketH = 220;
            const floorY = cy + 100;
            const holeW = 80; // Wider hole
            const tilt = 40; // Steeper tilt

            // 1. Draw Container (Glass)
            ctx.save();
            ctx.shadowColor = 'rgba(255,255,255,0.2)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            // Left Wall
            ctx.moveTo(cx - bucketW / 2, cy - bucketH / 2);
            ctx.lineTo(cx - bucketW / 2, floorY - tilt);
            // Left Floor (Tilted)
            ctx.lineTo(cx - holeW / 2, floorY);
            // Right Floor (Tilted)
            ctx.moveTo(cx + holeW / 2, floorY);
            ctx.lineTo(cx + bucketW / 2, floorY - tilt);
            // Right Wall
            ctx.lineTo(cx + bucketW / 2, cy - bucketH / 2);
            ctx.stroke();

            // Label
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText("THE LABOR MARKET", cx, floorY + 30);

            ctx.shadowBlur = 0;
            ctx.restore();

            // 2. Particle System
            if (!simState.droplets) simState.droplets = [];

            // Emitter (The Stimulus)
            if (simState.stimulusActive) {
                // Pour MORE particles (smaller)
                for (let i = 0; i < 20; i++) {
                    simState.droplets.push({
                        x: cx + (Math.random() - 0.5) * 40,
                        y: cy - bucketH / 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: 5 + Math.random() * 5,
                        r: 1.5 + Math.random() * 1.5,
                        life: 300
                    });
                }
                // Timer logic
                if (!simState.timer) simState.timer = 0;
                simState.timer++;
                if (simState.timer > 60) { // 1 second pour (shorter)
                    simState.stimulusActive = false;
                    simState.timer = 0;
                }
            }

            // Physics & Render
            ctx.fillStyle = '#06b6d4'; // Cyan Water

            simState.droplets.forEach(p => {
                p.vy += 0.3; // Gravity
                p.x += p.vx;
                p.y += p.vy;

                // Floor Collision (Tilted)
                let floorHeightAtX = floorY;

                // Left Side
                if (p.x < cx - holeW / 2 && p.x > cx - bucketW / 2) {
                    const progress = (p.x - (cx - bucketW / 2)) / ((bucketW - holeW) / 2);
                    floorHeightAtX = (floorY - tilt) + progress * tilt;

                    if (p.y > floorHeightAtX - p.r) {
                        p.y = floorHeightAtX - p.r;
                        // Slide towards center (positive x)
                        p.vx += 0.8; // Stronger slide
                        p.vy *= -0.4; // Dampen
                        p.vx *= 0.9;  // Friction
                    }
                }
                // Right Side
                else if (p.x > cx + holeW / 2 && p.x < cx + bucketW / 2) {
                    const progress = ((cx + bucketW / 2) - p.x) / ((bucketW - holeW) / 2);
                    floorHeightAtX = (floorY - tilt) + progress * tilt;

                    if (p.y > floorHeightAtX - p.r) {
                        p.y = floorHeightAtX - p.r;
                        // Slide towards center (negative x)
                        p.vx -= 0.8; // Stronger slide
                        p.vy *= -0.4; // Dampen
                        p.vx *= 0.9;  // Friction
                    }
                }

                // Wall Collision
                if (p.x < cx - bucketW / 2 + p.r) {
                    p.x = cx - bucketW / 2 + p.r;
                    p.vx *= -0.5;
                }
                if (p.x > cx + bucketW / 2 - p.r) {
                    p.x = cx + bucketW / 2 - p.r;
                    p.vx *= -0.5;
                }

                // Draw
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fill();

                // Cleanup
                if (p.y > h) p.life = 0;
            });

            // Remove dead particles
            simState.droplets = simState.droplets.filter(p => p.life > 0);

            // Text Overlay
            if (simState.droplets.length === 0 && !simState.stimulusActive) {
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '16px monospace';
                ctx.fillText("SYSTEM READY FOR INJECTION", cx, cy - 60);
            } else if (simState.droplets.length > 0) {
                // Count particles in bucket
                const trapped = simState.droplets.filter(p => p.y < floorY && p.y > floorY - 50).length;
                if (trapped < 10 && !simState.stimulusActive) {
                    ctx.fillStyle = '#ef4444';
                    ctx.textAlign = 'center';
                    ctx.fillText("LIQUIDITY DRAINING...", cx, cy - 20);
                }
            }
        }
        window.triggerStimulus = () => { simState.stimulusActive = true; }

        function renderScale(w, h, t) {
            // Circuit Rewiring
            const shift = simParams.p1; // 0 to 100

            const prodX = w * 0.2;
            const consX = w * 0.8;
            const laborY = h * 0.8;
            const directY = h * 0.2;

            // Nodes
            ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(prodX, h / 2, 30, 0, Math.PI * 2); ctx.fill(); // Prod
            ctx.fillStyle = '#fff'; ctx.fillText("PRODUCTION", prodX, h / 2 + 50);

            ctx.fillStyle = '#10b981'; ctx.beginPath(); ctx.arc(consX, h / 2, 30, 0, Math.PI * 2); ctx.fill(); // Cons
            ctx.fillStyle = '#fff'; ctx.fillText("CONSUMPTION", consX, h / 2 + 50);

            // Old Path (Labor)
            ctx.strokeStyle = '#555'; ctx.lineWidth = 8;
            ctx.beginPath(); ctx.moveTo(prodX, h / 2); ctx.lineTo(w / 2, laborY); ctx.lineTo(consX, h / 2); ctx.stroke();

            // New Path (Direct) - Opacity based on shift
            ctx.strokeStyle = `rgba(6, 182, 212, ${shift / 100})`;
            ctx.lineWidth = 8 + (Math.sin(t * 10) * 2); // Pulse
            ctx.shadowColor = '#06b6d4'; ctx.shadowBlur = shift / 5;
            ctx.beginPath(); ctx.moveTo(prodX, h / 2); ctx.lineTo(w / 2, directY); ctx.lineTo(consX, h / 2); ctx.stroke();
            ctx.shadowBlur = 0;

            // Electrons
            if (Math.floor(t * 10) % 3 === 0) {
                if (!simState.electrons) simState.electrons = [];
                simState.electrons.push({ p: 0, path: shift > 50 ? 'new' : 'old' });
            }

            if (simState.electrons) {
                simState.electrons.forEach((e, i) => {
                    e.p += 0.02;
                    let ex, ey;
                    if (e.path === 'old') {
                        if (e.p < 0.5) {
                            ex = prodX + (w / 2 - prodX) * (e.p * 2);
                            ey = h / 2 + (laborY - h / 2) * (e.p * 2);
                        } else {
                            ex = w / 2 + (consX - w / 2) * ((e.p - 0.5) * 2);
                            ey = laborY + (h / 2 - laborY) * ((e.p - 0.5) * 2);
                        }
                        // Broken path effect
                        if (shift > 20 && Math.random() > 0.8) ctx.fillStyle = 'red';
                        else ctx.fillStyle = '#fff';
                    } else {
                        if (e.p < 0.5) {
                            ex = prodX + (w / 2 - prodX) * (e.p * 2);
                            ey = h / 2 + (directY - h / 2) * (e.p * 2);
                        } else {
                            ex = w / 2 + (consX - w / 2) * ((e.p - 0.5) * 2);
                            ey = directY + (h / 2 - directY) * ((e.p - 0.5) * 2);
                        }
                        ctx.fillStyle = '#06b6d4';
                    }

                    ctx.beginPath(); ctx.arc(ex, ey, 6, 0, Math.PI * 2); ctx.fill();
                    if (e.p >= 1) simState.electrons.splice(i, 1);
                });
            }
        }

        function renderDividend(w, h, t) {
            const year = parseInt(simParams.p1); // 2060 to 2100
            const progress = (year - 2060) / 40; // 0 to 1
            const cx = w / 2;
            const cy = h / 2;

            // 1. BACKGROUND: ROBOT ARMY
            // A grid of dots/icons that gets denser and brighter
            const rows = 10;
            const cols = 20;
            const robotCount = Math.floor(progress * 200); // 0 to 200 robots

            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, w, h); // Dark bg

            for (let i = 0; i < 200; i++) {
                const r = Math.floor(i / cols);
                const c = i % cols;
                const x = 50 + c * ((w - 100) / cols);
                const y = 50 + r * ((h / 2) / rows);

                if (i < robotCount) {
                    // Active Robot
                    ctx.fillStyle = '#f59e0b';
                    ctx.shadowColor = '#f59e0b';
                    ctx.shadowBlur = 5;
                    ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;

                    // Connection lines (Network effect)
                    if (Math.random() < 0.05) {
                        ctx.strokeStyle = 'rgba(245, 158, 11, 0.2)';
                        ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + (Math.random() - 0.5) * 50, y + (Math.random() - 0.5) * 50); ctx.stroke();
                    }
                } else {
                    // Inactive/Ghost
                    ctx.fillStyle = '#333';
                    ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();
                }
            }

            // 2. METRICS (The Graphs)
            const graphY = h * 0.6;
            const graphH = h * 0.3;
            const graphW = w * 0.4;

            // A. COST OF LIVING (Plummeting)
            const costVal = 1.0 - (progress * 0.95); // Drops to 5%
            const costH = costVal * graphH;

            ctx.fillStyle = '#ef4444';
            ctx.fillRect(50, graphY + (graphH - costH), 40, costH);
            ctx.textAlign = 'center';
            ctx.font = '12px monospace';
            ctx.fillStyle = '#fff';
            ctx.fillText("COSTS", 70, graphY + graphH + 20);
            ctx.fillText((costVal * 100).toFixed(0) + "%", 70, graphY + (graphH - costH) - 10);

            // B. DIVIDEND (Skyrocketing)
            // Exponential growth
            const divVal = 0.1 + (Math.pow(progress, 2) * 0.9);
            const divH = divVal * graphH;

            // Animated Bar
            const barX = w - 100;
            const barW = 60;

            // Gradient
            const grad = ctx.createLinearGradient(0, graphY + graphH - divH, 0, graphY + graphH);
            grad.addColorStop(0, '#10b981');
            grad.addColorStop(1, '#064e3b');

            ctx.fillStyle = grad;
            ctx.shadowColor = '#10b981';
            ctx.shadowBlur = 20 * progress;
            ctx.fillRect(barX, graphY + graphH - divH, barW, divH);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff';
            ctx.fillText("DIVIDEND", barX + barW / 2, graphY + graphH + 20);
            ctx.font = 'bold 16px monospace';
            ctx.fillText("$" + (1000 + progress * 9000).toFixed(0), barX + barW / 2, graphY + graphH - divH - 10);

            // 3. FLOW PARTICLES (Transfer)
            // Particles flying from Robot Army to Dividend Bar
            if (progress > 0.1) {
                if (!simState.divFlow) simState.divFlow = [];

                // Spawn based on progress
                const spawnRate = progress * 0.5;
                if (Math.random() < spawnRate) {
                    simState.divFlow.push({
                        x: w * 0.3 + (Math.random() * w * 0.2), // Start from robot area
                        y: h * 0.2 + (Math.random() * h * 0.2),
                        vx: (Math.random() * 2) + 2,
                        vy: (Math.random() * 2) + 2,
                        life: 1.0
                    });
                }

                ctx.fillStyle = '#10b981';
                simState.divFlow.forEach((p, i) => {
                    // Move towards Dividend Bar top
                    const targetX = barX + barW / 2;
                    const targetY = graphY + graphH - divH;

                    const dx = targetX - p.x;
                    const dy = targetY - p.y;

                    p.x += dx * 0.05;
                    p.y += dy * 0.05;

                    // Draw
                    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();

                    // Kill if close
                    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                        simState.divFlow.splice(i, 1);
                    }
                });
            }

            // 4. YEAR DISPLAY
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 40px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(year, w / 2, h - 30);
        }

        function renderPurpose(w, h, t) {
            const focus = simParams.p1; // 0 to 100
            const vitality = focus / 100; // 0 to 1

            // Initialize Seed
            if (!simState.seed) simState.seed = 12345;

            // Stateless PRNG (Hash)
            function hash(n) {
                return Math.abs(Math.sin(n * 12.9898 + simState.seed) * 43758.5453) % 1;
            }

            // 1. Background
            const r = 10 + (200 * vitality);
            const g = 15 + (180 * vitality);
            const b = 30 + (100 * vitality);

            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, `rgb(${r * 0.5}, ${g * 0.5}, ${b * 0.8})`);
            grad.addColorStop(1, `rgb(${r}, ${g}, ${b})`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Sun
            const sunY = h * 0.8 - (h * 0.6 * vitality);
            ctx.fillStyle = `rgba(255, 255, 200, ${0.1 + vitality * 0.4})`;
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 20 + vitality * 50;
            ctx.beginPath(); ctx.arc(w / 2, sunY, 40 + vitality * 40, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;

            // 2. Birds
            if (vitality > 0.4) {
                if (!simState.birds) {
                    simState.birds = Array.from({ length: 10 }, (_, i) => ({
                        x: Math.random() * w,
                        y: Math.random() * h * 0.5,
                        speed: 0.5 + Math.random(),
                        offset: Math.random() * 100
                    }));
                }

                ctx.fillStyle = `rgba(0,0,0,${vitality})`;
                simState.birds.forEach(bird => {
                    bird.x += bird.speed;
                    if (bird.x > w) bird.x = -20;

                    const flyY = bird.y + Math.sin(t * 2 + bird.offset) * 10;
                    const wing = Math.sin(t * 10 + bird.offset) * 5;

                    ctx.beginPath();
                    ctx.moveTo(bird.x, flyY);
                    ctx.lineTo(bird.x - 5, flyY - wing); // Left wing
                    ctx.lineTo(bird.x + 5, flyY - wing); // Right wing
                    ctx.lineTo(bird.x, flyY + 2); // Body
                    ctx.fill();
                });
            }

            // 3. Stable Procedural Tree
            const cx = w / 2;
            const cy = h;
            const maxDepth = 10;

            // Wind
            const wind = Math.sin(t * 0.5) * 2 + Math.sin(t * 1.5) * 0.5;

            // Recursive function passes a unique 'id' for randomness
            function drawBranch(x, y, len, angle, width, depth, id) {
                ctx.beginPath();
                ctx.save();

                // Properties derived from ID (Stable)
                const rCurve = hash(id + 1);
                const rBranchCount = hash(id + 2);

                // Color
                if (depth < 3) ctx.strokeStyle = '#5d4037';
                else ctx.strokeStyle = vitality > 0.5 ? '#10b981' : '#8b5a2b';

                ctx.lineWidth = width;
                ctx.translate(x, y);

                const finalAngle = angle + (wind * (depth * 0.5));
                ctx.rotate(finalAngle * Math.PI / 180);

                ctx.moveTo(0, 0);
                const curveX = (rCurve - 0.5) * 20;
                ctx.quadraticCurveTo(curveX, -len / 2, 0, -len);
                ctx.stroke();

                if (depth >= maxDepth || len < 5) {
                    // Flowers
                    const rFlower = hash(id + 3);
                    if (vitality > 0.3 && rFlower > 0.5) {
                        const type = hash(id + 4);
                        ctx.fillStyle = type > 0.7 ? '#f59e0b' : (type > 0.4 ? '#ec4899' : '#10b981');
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.shadowBlur = vitality * 10;

                        const size = (vitality * 6) * hash(id + 5);
                        if (size > 0) {
                            ctx.beginPath();
                            ctx.arc(0, -len, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                    }
                    ctx.restore();
                    return;
                }

                // Branching
                const growthThreshold = depth / maxDepth;
                if (vitality > growthThreshold - 0.2) {
                    const branchCount = 2 + Math.floor(rBranchCount * 1.5); // 2 or 3

                    for (let i = 0; i < branchCount; i++) {
                        // Unique ID for child: ParentID * Prime + Index
                        const childId = id * 13 + i * 7;

                        const rLen = hash(childId + 10);
                        const rSpread = hash(childId + 11);
                        const rAngle = hash(childId + 12);

                        const nextLen = len * (0.6 + rLen * 0.2);
                        const nextWidth = width * 0.7;
                        const spread = 20 + rSpread * 40;
                        const nextAngle = -spread / 2 + (spread * i) + (rAngle - 0.5) * 20;

                        drawBranch(0, -len, nextLen, nextAngle, nextWidth, depth + 1, childId);
                    }
                }

                ctx.restore();
            }

            // Start Tree with ID 1
            const baseLen = 100 + hash(simState.seed) * 40;
            drawBranch(cx, cy, baseLen * (0.2 + vitality * 0.8), 0, 15, 0, 1);

            // 4. Particles
            if (vitality > 0.3) {
                if (Math.random() < vitality * 0.2) {
                    if (!simState.pollen) simState.pollen = [];
                    simState.pollen.push({
                        x: cx + (Math.random() - 0.5) * 300,
                        y: h - Math.random() * 300,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2,
                        life: 1
                    });
                }
            }

            if (simState.pollen) {
                simState.pollen.forEach((p, i) => {
                    p.x += p.vx + Math.sin(t + p.y * 0.01);
                    p.y += p.vy;
                    p.life -= 0.01;
                    ctx.fillStyle = `rgba(255, 215, 0, ${p.life})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill();
                    if (p.life <= 0) simState.pollen.splice(i, 1);
                });
            }

            if (vitality < 0.1) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'center';
                ctx.font = '14px monospace';
                ctx.fillText("The seed is dormant...", cx, h - 20);
            }
        }

        function renderStatus(w, h, t) {
            const reach = simParams.p1; // 10-100 Speed/Range
            const stickiness = simParams.p2 || 50; // 10-100 Conversion Power

            // Initialize Battle
            if (!simState.boids) {
                simState.boids = [];
                // 100 Grey (Public)
                for (let i = 0; i < 100; i++) simState.boids.push(createBoid(w, h, 'grey'));
                // 5 Red (Enemy)
                for (let i = 0; i < 5; i++) simState.boids.push(createBoid(w, h, 'red'));
                // 5 Blue (Player)
                for (let i = 0; i < 5; i++) simState.boids.push(createBoid(w, h, 'blue'));
            }

            // Stats
            let blueCount = 0;
            let redCount = 0;

            // Update Boids
            simState.boids.forEach(b => {
                if (b.team === 'blue') blueCount++;
                if (b.team === 'red') redCount++;

                // 1. Physics (Flocking + Pursuit)
                let alignX = 0, alignY = 0;
                let cohX = 0, cohY = 0;
                let sepX = 0, sepY = 0;
                let targetX = 0, targetY = 0;
                let neighborCount = 0;

                // Find neighbors
                simState.boids.forEach(other => {
                    if (b === other) return;
                    const dx = other.x - b.x;
                    const dy = other.y - b.y;
                    const dist = Math.hypot(dx, dy);

                    // Flocking (Same Team)
                    if (b.team === other.team && dist < 50) {
                        alignX += other.vx;
                        alignY += other.vy;
                        cohX += other.x;
                        cohY += other.y;
                        neighborCount++;
                    }

                    // Separation (Everyone)
                    if (dist < 20) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                    }

                    // Pursuit/Battle (Different Team)
                    // Blue chases Grey/Red. Red chases Grey/Blue.
                    if (b.team !== 'grey' && other.team !== b.team && dist < 150) {
                        // Attract to convertible targets
                        targetX += other.x;
                        targetY += other.y;
                    }
                });

                // Apply Flocking Forces
                if (neighborCount > 0) {
                    alignX /= neighborCount; alignY /= neighborCount;
                    cohX /= neighborCount; cohY /= neighborCount;

                    // Steer towards cohesion
                    b.vx += (cohX - b.x) * 0.005;
                    b.vy += (cohY - b.y) * 0.005;
                    // Match velocity
                    b.vx += (alignX - b.vx) * 0.01;
                    b.vy += (alignY - b.vy) * 0.01;
                }

                // Apply Separation
                b.vx += sepX * 0.5;
                b.vy += sepY * 0.5;

                // Apply Targeting (The "Reach" param affects how aggressive Blue is)
                if (b.team === 'blue') {
                    const aggression = reach / 5000;
                    b.vx += (targetX - b.x) * aggression;
                    b.vy += (targetY - b.y) * aggression;
                } else if (b.team === 'red') {
                    b.vx += (targetX - b.x) * 0.01; // Fixed aggression for Red
                    b.vy += (targetY - b.y) * 0.01;
                }

                // Friction & Speed Limit
                const speed = Math.hypot(b.vx, b.vy);
                const maxSpeed = b.team === 'blue' ? (2 + reach / 20) : 3; // Blue speed depends on Reach
                if (speed > maxSpeed) {
                    b.vx = (b.vx / speed) * maxSpeed;
                    b.vy = (b.vy / speed) * maxSpeed;
                }

                // Move
                b.x += b.vx;
                b.y += b.vy;

                // Wrap
                if (b.x < 0) b.x = w; if (b.x > w) b.x = 0;
                if (b.y < 0) b.y = h; if (b.y > h) b.y = 0;

                // 2. Infection / Combat Logic
                simState.boids.forEach(other => {
                    if (b === other) return;
                    const dx = other.x - b.x;
                    const dy = other.y - b.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < 10) {
                        // Collision!
                        if (b.team === 'blue' && other.team !== 'blue') {
                            // Blue tries to convert
                            // Chance = Stickiness vs Resistance
                            // Grey has low resistance. Red has high.
                            let chance = stickiness / 100;
                            if (other.team === 'red') chance *= 0.2; // Hard to convert Red

                            if (Math.random() < chance) {
                                other.team = 'blue';
                                // Spark effect
                                ctx.fillStyle = '#fff';
                                ctx.beginPath(); ctx.arc(other.x, other.y, 10, 0, Math.PI * 2); ctx.fill();
                            }
                        } else if (b.team === 'red' && other.team !== 'red') {
                            // Red tries to convert
                            if (Math.random() < 0.05) { // Fixed Red power
                                other.team = 'red';
                            }
                        }
                    }
                });

                // 3. Draw
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(Math.atan2(b.vy, b.vx));

                if (b.team === 'blue') {
                    ctx.fillStyle = '#06b6d4';
                    ctx.shadowColor = '#06b6d4'; ctx.shadowBlur = 10;
                } else if (b.team === 'red') {
                    ctx.fillStyle = '#ef4444';
                    ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 10;
                } else {
                    ctx.fillStyle = '#475569'; // Grey
                    ctx.shadowBlur = 0;
                }

                // Triangle
                ctx.beginPath();
                ctx.moveTo(6, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.fill();
                ctx.restore();
            });

            // Score Overlay
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#06b6d4'; ctx.fillText(`BLUE: ${blueCount}`, 20, 40);
            ctx.fillStyle = '#ef4444'; ctx.fillText(`RED:  ${redCount}`, 20, 70);

            if (blueCount > 90) {
                ctx.textAlign = 'center';
                ctx.fillStyle = '#06b6d4';
                ctx.font = 'bold 40px sans-serif';
                ctx.fillText("NARRATIVE DOMINANCE", w / 2, h / 2);
            }
        }

        function createBoid(w, h, team) {
            return {
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                team: team
            };
        }

        window.resetStatusSim = () => {
            simState.boids = null;
        };

        function renderLand(w, h, t) {
            // AUTO-LOTTERY SIMULATION
            // Concept: 3 Tiers. Agents live there. Every few seconds, they shuffle.

            const bottomPadding = 200;
            const usableH = h - bottomPadding - 50;

            // Initialize State
            if (!simState.land || simState.land.grid) { // Reset if coming from Fluid Reality
                simState.land = {
                    households: [],
                    phase: 'DWELL', // DWELL, SHUFFLE, MIGRATE
                    timer: 0,
                    cycle: 0
                };
                // Create 100 households
                for (let i = 0; i < 100; i++) {
                    // Initial random distribution
                    const tier = Math.floor(Math.random() * 3) + 1;
                    simState.land.households.push({
                        id: i,
                        tier: tier,
                        targetTier: tier,
                        x: Math.random() * w,
                        y: Math.random() * h, // Will be fixed by logic
                        color: '#fff'
                    });
                }
            }
            const state = simState.land;

            // Tiers Layout
            const tiers = [
                { id: 1, label: "TIER 1: LUXURY (Beach/Sky)", color: '#f59e0b', y: 50, h: usableH * 0.25 },
                { id: 2, label: "TIER 2: PREMIUM (City)", color: '#06b6d4', y: 50 + usableH * 0.28, h: usableH * 0.3 },
                { id: 3, label: "TIER 3: STANDARD (Metro)", color: '#10b981', y: 50 + usableH * 0.61, h: usableH * 0.39 }
            ];

            // Logic
            state.timer += 0.016;

            if (state.phase === 'DWELL') {
                if (state.timer > 3.0) {
                    state.phase = 'SHUFFLE';
                    state.timer = 0;
                }
            } else if (state.phase === 'SHUFFLE') {
                if (state.timer > 1.0) {
                    state.phase = 'MIGRATE';
                    state.timer = 0;
                    state.cycle++;

                    // RANDOMIZE TIERS
                    state.households.forEach(p => {
                        // Weighted random for realism? Or pure random?
                        // Let's do pure random to emphasize the "Lottery" aspect
                        const r = Math.random();
                        if (r < 0.15) p.targetTier = 1; // 15% Luxury
                        else if (r < 0.45) p.targetTier = 2; // 30% Premium
                        else p.targetTier = 3; // 55% Standard
                    });
                }
            } else if (state.phase === 'MIGRATE') {
                if (state.timer > 2.0) {
                    state.phase = 'DWELL';
                    state.timer = 0;
                    state.households.forEach(p => p.tier = p.targetTier);
                }
            }

            // Update Particles
            state.households.forEach(p => {
                const currentTierObj = tiers.find(t => t.id === (state.phase === 'MIGRATE' ? p.targetTier : p.tier));

                // Target Position
                let tx = p.x;
                let ty = p.y;

                if (state.phase === 'DWELL' || state.phase === 'SHUFFLE') {
                    // Drift within current tier
                    const tierObj = tiers.find(t => t.id === p.tier);
                    // Keep x within bounds
                    if (!p.tx || Math.random() < 0.02) {
                        p.tx = 50 + Math.random() * (w - 100);
                        p.ty = tierObj.y + 20 + Math.random() * (tierObj.h - 40);
                    }
                    tx = p.tx;
                    ty = p.ty;
                } else if (state.phase === 'MIGRATE') {
                    // Move to new tier
                    const tierObj = tiers.find(t => t.id === p.targetTier);
                    if (!p.txMigrate || Math.random() < 0.05) {
                        p.txMigrate = 50 + Math.random() * (w - 100);
                        p.tyMigrate = tierObj.y + 20 + Math.random() * (tierObj.h - 40);
                    }
                    tx = p.txMigrate;
                    ty = p.tyMigrate;
                }

                // Move
                const speed = (state.phase === 'MIGRATE') ? 0.1 : 0.02;
                p.x += (tx - p.x) * speed;
                p.y += (ty - p.y) * speed;
            });

            // --- RENDER ---

            // Draw Tiers
            tiers.forEach(tier => {
                // Glow
                const grad = ctx.createLinearGradient(0, tier.y, 0, tier.y + tier.h);
                grad.addColorStop(0, tier.color + '11');
                grad.addColorStop(1, tier.color + '00');
                ctx.fillStyle = grad;
                ctx.fillRect(20, tier.y, w - 40, tier.h);

                // Border
                ctx.strokeStyle = tier.color;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5;
                ctx.strokeRect(20, tier.y, w - 40, tier.h);
                ctx.globalAlpha = 1;

                // Label
                ctx.fillStyle = tier.color;
                ctx.font = 'bold 12px monospace';
                ctx.fillText(tier.label, 30, tier.y + 20);
            });

            // Draw Households
            state.households.forEach(p => {
                // Color
                let color = '#fff';
                const tierId = (state.phase === 'MIGRATE') ? p.targetTier : p.tier;
                const tierObj = tiers.find(t => t.id === tierId);
                if (tierObj) color = tierObj.color;

                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                if (tierId === 1) { // Triangle
                    ctx.moveTo(p.x, p.y - 5); ctx.lineTo(p.x + 5, p.y + 5); ctx.lineTo(p.x - 5, p.y + 5);
                } else if (tierId === 2) { // Square
                    ctx.rect(p.x - 4, p.y - 4, 8, 8);
                } else { // Circle
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                }
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            // Status Text
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.font = '16px monospace';

            let status = `CYCLE ${state.cycle}: STABLE OCCUPANCY`;
            if (state.phase === 'SHUFFLE') {
                ctx.fillStyle = '#f59e0b';
                status = "⚠ LEASE EXPIRING... INITIATING LOTTERY ⚠";
            } else if (state.phase === 'MIGRATE') {
                ctx.fillStyle = '#06b6d4';
                status = ">>> RE-ALLOCATION IN PROGRESS >>>";
            }

            ctx.fillText(status, w / 2, h - bottomPadding + 30);

        }

        function renderGuardrails(w, h, t) {
            const autonomy = simParams.p1; // 0 to 100
            const cx = w / 2;
            const cy = h / 2;

            // Risk Calculation
            const riskLevel = Math.max(0, (autonomy - 70) / 30); // 0 to 1 starting at 70
            const isCritical = autonomy > 90;

            // Shake Effect (Global if critical)
            let sx = 0, sy = 0;
            if (riskLevel > 0) {
                const shake = riskLevel * 5;
                sx = (Math.random() - 0.5) * shake;
                sy = (Math.random() - 0.5) * shake;
            }

            ctx.save();
            ctx.translate(cx + sx, cy + sy);

            // 1. THE CORE (AI Intelligence)
            // Pulsing size based on autonomy
            const corePulse = Math.sin(t * (5 + riskLevel * 20)) * (5 + riskLevel * 10);
            const coreSize = 40 + (autonomy / 100) * 20 + corePulse;

            // Core Color: Cyan -> Orange -> Red
            let coreColor = `hsl(180, 100%, 50%)`; // Cyan
            if (autonomy > 50) coreColor = `hsl(40, 100%, 60%)`; // Orange
            if (autonomy > 85) coreColor = `hsl(0, 100%, 50%)`; // Red

            // Core Glow
            const grad = ctx.createRadialGradient(0, 0, coreSize * 0.2, 0, 0, coreSize);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.4, coreColor);
            grad.addColorStop(1, 'transparent');

            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, coreSize, 0, Math.PI * 2); ctx.fill();

            // Inner Core Noise (Data processing)
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 5; i++) {
                const a = Math.random() * Math.PI * 2;
                const r = Math.random() * coreSize * 0.5;
                ctx.beginPath(); ctx.arc(Math.cos(a) * r, Math.sin(a) * r, 2, 0, Math.PI * 2); ctx.fill();
            }

            // 2. CONTAINMENT SHIELDS (Rings)
            // 3 Layers of shields
            const shields = [
                { r: 80, speed: 1, segments: 3, width: 4 },
                { r: 110, speed: -0.8, segments: 5, width: 2 },
                { r: 140, speed: 0.5, segments: 12, width: 6 }
            ];

            shields.forEach((shield, i) => {
                ctx.rotate(t * shield.speed * (1 + riskLevel * 2)); // Spin faster with risk

                // Shield Integrity (Flicker/Break if high risk)
                const integrity = 1 - (riskLevel * 0.8 * Math.random());

                ctx.strokeStyle = (isCritical && Math.random() < 0.3) ? '#ef4444' : '#06b6d4';
                ctx.lineWidth = shield.width;
                ctx.lineCap = 'round';

                const segAngle = (Math.PI * 2) / shield.segments;
                const gap = 0.2 + riskLevel * 0.5; // Gaps widen with risk

                for (let j = 0; j < shield.segments; j++) {
                    if (Math.random() > integrity) continue; // Segment failed

                    ctx.beginPath();
                    ctx.arc(0, 0, shield.r, j * segAngle, j * segAngle + segAngle - gap);
                    ctx.stroke();
                }

                ctx.rotate(-t * shield.speed * (1 + riskLevel * 2)); // Reset rotation for next
            });

            // 3. BREACH PARTICLES
            if (riskLevel > 0) {
                const pCount = Math.floor(riskLevel * 20);
                ctx.fillStyle = '#ef4444';
                for (let i = 0; i < pCount; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const r = 60 + Math.random() * 100;
                    const size = Math.random() * 4;
                    ctx.beginPath(); ctx.arc(Math.cos(a) * r, Math.sin(a) * r, size, 0, Math.PI * 2); ctx.fill();
                }
            }

            ctx.restore();

            // 4. HUD / STATUS TEXT
            ctx.textAlign = 'center';
            ctx.font = 'bold 16px monospace';

            // Bar at bottom
            const barW = 300;
            const barH = 10;
            const barX = cx - barW / 2;
            const barY = cy + 180;

            // Background
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barW, barH);

            // Fill
            ctx.fillStyle = coreColor;
            ctx.fillRect(barX, barY, barW * (autonomy / 100), barH);

            // Text
            ctx.fillStyle = '#fff';
            ctx.fillText(`AUTONOMY LEVEL: ${autonomy}%`, cx, barY - 15);

            if (isCritical) {
                if (Math.floor(t * 5) % 2 === 0) { // Flash
                    ctx.fillStyle = '#ef4444';
                    ctx.font = 'bold 24px monospace';
                    ctx.fillText("⚠ CONTAINMENT FAILURE IMMINENT ⚠", cx, barY + 40);
                }
            } else if (riskLevel > 0) {
                ctx.fillStyle = '#f59e0b';
                ctx.fillText("WARNING: STABILITY COMPROMISED", cx, barY + 40);
            } else {
                ctx.fillStyle = '#06b6d4';
                ctx.fillText("SYSTEMS NOMINAL", cx, barY + 40);
            }
        }

        function renderSpace(w, h, t) {
            // Starfield (Parallax)
            if (!simState.stars) {
                simState.stars = Array.from({ length: 200 }, () => ({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    z: Math.random() * 2 + 0.5 // Speed/Depth
                }));
            }

            // Move Stars
            const speed = simState.launch ? (simState.launchTime * simState.launchTime * 0.5) : 0;
            simState.stars.forEach(s => {
                s.y += speed * s.z;
                if (s.y > h) { s.y = 0; s.x = Math.random() * w; }

                const brightness = Math.min(1, speed / 10 + 0.5);
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.fillRect(s.x, s.y, s.z, s.z * (1 + speed / 5)); // Stretch
            });

            // Earth (Fades out)
            if (!simState.launch || simState.launchTime < 5) {
                const earthY = h + (simState.launch ? simState.launchTime * 50 : 0);
                ctx.fillStyle = '#1d4ed8'; // Ocean
                ctx.beginPath(); ctx.arc(w / 2, earthY + 800, 900, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#10b981'; // Land
                ctx.beginPath(); ctx.arc(w / 2 + 100, earthY + 800, 850, 0, Math.PI * 2); ctx.fill();
            }

            // Ship
            const shipY = simState.launch ? (h - 100 - simState.launchTime * 2) : (h - 100);
            const shake = simState.launch ? (Math.random() - 0.5) * Math.min(5, simState.launchTime) : 0;

            ctx.save();
            ctx.translate(w / 2 + shake, Math.min(h / 2, shipY)); // Camera follows ship after midpoint

            // Rocket Body
            ctx.fillStyle = '#e2e8f0';
            ctx.beginPath();
            ctx.moveTo(0, -40);
            ctx.quadraticCurveTo(15, -10, 15, 30);
            ctx.lineTo(-15, 30);
            ctx.quadraticCurveTo(-15, -10, 0, -40);
            ctx.fill();

            // Fins
            ctx.fillStyle = '#ef4444';
            ctx.beginPath(); ctx.moveTo(-15, 10); ctx.lineTo(-25, 40); ctx.lineTo(-15, 30); ctx.fill();
            ctx.beginPath(); ctx.moveTo(15, 10); ctx.lineTo(25, 40); ctx.lineTo(15, 30); ctx.fill();

            // Window
            ctx.fillStyle = '#06b6d4';
            ctx.beginPath(); ctx.arc(0, -10, 5, 0, Math.PI * 2); ctx.fill();

            // Engine Plume
            if (simState.launch) {
                simState.launchTime += 0.05;

                ctx.fillStyle = '#f59e0b';
                ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(-10, 30);
                ctx.lineTo(0, 30 + 50 + Math.random() * 50 + (simState.launchTime * 10));
                ctx.lineTo(10, 30);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Particles
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc((Math.random() - 0.5) * 20, 30 + Math.random() * 50, Math.random() * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();

            // Text Overlay (Drawn last to be on top)
            if (!simState.launch) {
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = '16px monospace';
                ctx.fillText("AWAITING LAUNCH COMMAND", w / 2, h / 2 - 60);
            } else if (simState.launchTime > 10) {
                ctx.save();
                // Apple Style: Clean, no glow, thin weight
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';

                // Main Title
                ctx.font = '300 50px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                ctx.letterSpacing = '2px';
                ctx.fillText("MISSION: CENTAURI", w / 2, h / 2 - 120);

                // Subtitle
                ctx.font = '400 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.letterSpacing = '1px';
                ctx.fillText("VELOCITY: 0.2c  |  ETA: 20 YEARS", w / 2, h / 2 - 80);

                ctx.restore();
            }
        }

        window.triggerLaunch = () => {
            simState.launch = true;
            simState.launchTime = 0;
        }
    </script>
</body>

</html>
