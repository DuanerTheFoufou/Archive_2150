<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Grand Archive: 2025-2150</title>
    <style>
        :root {
            --bg-dark: #0a0b10;
            --bg-panel: #14161f;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --accent-cyan: #06b6d4;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-gold: #f59e0b;
            --border: 1px solid rgba(255,255,255,0.08);
            --font-mono: 'Courier New', monospace;
            --font-sans: system-ui, -apple-system, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: var(--font-sans);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- LAYOUT --- */
        .main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - 60px); /* Subtract header */
        }

        /* SIDEBAR (Timeline) */
        .sidebar {
            width: 280px;
            background: var(--bg-panel);
            border-right: var(--border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .timeline-item {
            padding: 15px 20px;
            border-bottom: var(--border);
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.6;
            display: flex;
            flex-direction: column;
        }

        .timeline-item:hover { opacity: 1; background: rgba(255,255,255,0.02); }
        .timeline-item.active {
            opacity: 1;
            background: rgba(6, 182, 212, 0.1);
            border-left: 3px solid var(--accent-cyan);
        }

        .t-year { font-family: var(--font-mono); font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 4px; }
        .t-title { font-size: 0.95rem; font-weight: 600; }

        /* CENTER (Narrative) */
        .narrative {
            flex: 1;
            max-width: 500px;
            padding: 40px;
            overflow-y: auto;
            border-right: var(--border);
            background: radial-gradient(circle at top left, #1a1d26 0%, #0a0b10 100%);
        }

        h1 { font-size: 2rem; margin-bottom: 10px; color: white; letter-spacing: -0.5px; }
        h2 { font-size: 0.9rem; color: var(--accent-gold); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 30px; font-family: var(--font-mono); }
        
        p { 
            line-height: 1.8; 
            color: var(--text-secondary); 
            margin-bottom: 25px; 
            font-size: 1.05rem; 
        }

        strong { color: var(--text-primary); }

        /* RIGHT (Simulation) */
        .simulation-area {
            flex: 1.5;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* CONTROLS OVERLAY */
        .controls-overlay {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 22, 31, 0.9);
            backdrop-filter: blur(10px);
            border: var(--border);
            padding: 20px;
            border-radius: 12px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
        }

        .control-group { margin-bottom: 15px; }
        .control-group:last-child { margin-bottom: 0; }
        
        label { 
            display: flex; justify-content: space-between; 
            font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; 
            margin-bottom: 8px; color: var(--text-secondary); 
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--accent-cyan);
            cursor: pointer;
        }

        /* HEADER */
        header {
            height: 60px;
            border-bottom: var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            background: var(--bg-dark);
            justify-content: space-between;
        }

        .archive-status { font-family: var(--font-mono); font-size: 0.8rem; color: var(--accent-green); }
        .nav-btn {
            background: var(--bg-panel); border: var(--border); color: white;
            padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 0.9rem;
            transition: 0.2s;
        }
        .nav-btn:hover { background: rgba(255,255,255,0.1); }
        .nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

    </style>
</head>
<body>

    <header>
        <div style="font-weight:bold;">ARCHIVE_2150 // HISTORICAL RECONSTRUCTION</div>
        <div class="archive-status">‚óè SYSTEM ONLINE</div>
    </header>

    <div class="main-container">
        <!-- 1. TIMELINE -->
        <div class="sidebar" id="sidebar">
            <!-- Injected via JS -->
        </div>

        <!-- 2. NARRATIVE -->
        <div class="narrative" id="narrativeContent">
            <!-- Injected via JS -->
        </div>

        <!-- 3. SIMULATION -->
        <div class="simulation-area">
            <canvas id="simCanvas"></canvas>
            <div class="controls-overlay" id="simControls">
                <!-- Injected via JS -->
            </div>
        </div>
    </div>

<script>
/**
 * --- DATA STRUCTURE: THE HISTORY ---
 * This array contains every "Section" of the lesson.
 */
const chapters = [
    {
        year: "2025",
        title: "The Spark",
        subtitle: "Where we stand today",
        text: `
            <p>Welcome, student. You are accessing this archive from the year 2150. We are looking back at the most turbulent century in human history.</p>
            <p>It starts in <strong>2025</strong>. At this moment, AI was still "Digital." Large Language Models (LLMs) could write code and poetry, but they were trapped in servers. They had no hands.</p>
            <p>The economy was stable. People worked for wages. Capital (machines) and Labor (humans) were roughly balanced partners. But the spark had been lit. The cost of intelligence was dropping by 10x every year.</p>
            <p><strong>Simulation:</strong> Observe the neural network. It is growing, but isolated. Adjust the <em>Compute Power</em> to see how the network density increases.</p>
        `,
        simId: "SPARK",
        controls: `<label>Compute Power <span id="val1">Low</span></label><input type="range" min="10" max="100" value="20" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2028-2032",
        title: "The Agentic Era",
        subtitle: "From Chatbots to Workers",
        text: `
            <p>By roughly 2030, AI stopped being a "chatbot" and became an "Agent."</p>
            <p>An Agent doesn't just talk; it <em>does</em>. It could browse the web, use software, send emails, and code entire apps without human intervention. This was the first wave of displacement: white-collar digital tasks.</p>
            <p>Data entry, basic coding, translation, and customer service began to automate. However, the economy held up because new roles (supervisors, prompt engineers) were created.</p>
            <p><strong>Simulation:</strong> Watch the "Task Queue." Previously, humans (Green) cleared tasks. Now, AI Agents (Blue) begin to intercept them.</p>
        `,
        simId: "AGENTS",
        controls: `<label>AI Autonomy Level <span id="val1">0%</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2035-2040",
        title: "The Physical Link",
        subtitle: "Robotics catches up",
        text: `
            <p>For a long time, we thought blue-collar jobs were safe. "AI can't fix a clear plumbing pipe," we said.</p>
            <p>We were wrong. By the late 2030s, humanoid robotics solved the battery and motor issues. Combined with the "Brain" of advanced AI, robots could now learn physical tasks by watching videos.</p>
            <p>This was the turning point. Automation left the screen and entered the factory, the warehouse, and the construction site.</p>
            <p><strong>Simulation:</strong> The robot arm. Increase <em>Dexterity</em> to see it match human speed and precision.</p>
        `,
        simId: "ROBOTICS",
        controls: `<label>Robotic Dexterity <span id="val1">Clumsy</span></label><input type="range" min="0" max="100" value="10" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2040-2050",
        title: "The Golden Twilight",
        subtitle: "The Boom before the Bust",
        text: `
            <p>This decade is often misunderstood. It wasn't a depression; it was a <strong>Boom</strong>.</p>
            <p>With robots working 24/7 for pennies, the cost of goods plummeted. TVs, cars, and houses became cheaper to build. Corporate profits hit all-time highs.</p>
            <p>Unemployment rose to 15%, but people survived on "Gig" work and cheap prices. We called it the "Golden Twilight" because everything looked shiny, but the sun was setting on the wage-labor system.</p>
            <p><strong>Simulation:</strong> Observe the "GDP" (Yellow Line) vs "Median Wage" (Green Line). Increase automation to see GDP soar while wages stagnate.</p>
        `,
        simId: "BOOM",
        controls: `<label>Automation Integration <span id="val1">Low</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2050-2055",
        title: "The Squeeze",
        subtitle: "The math breaks down",
        text: `
            <p>By 2050, the trend became undeniable. Human labor was no longer competitive. Why hire a human for $20/hour when a bot does it for $0.05/hour?</p>
            <p>Wages began to actively shrink. People took 2nd and 3rd jobs to compete. The "Gig Economy" became the "Desperation Economy."</p>
            <p>Crucially, debt began to default. People couldn't pay mortgages. The cracks in the foundation were visible to everyone.</p>
            <p><strong>Simulation:</strong> The Worker Pool. As you increase <em>Cost Pressure</em>, workers turn red (insolvent) and drop out of the economy.</p>
        `,
        simId: "SQUEEZE",
        controls: `<label>Corporate Cost Pressure <span id="val1">Normal</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2058",
        title: "The Velocity Freeze",
        subtitle: "Money stops moving",
        text: `
            <p>An economy requires the <strong>Velocity of Money</strong>. I pay you, you pay the grocer, the grocer pays the farmer.</p>
            <p>In 2058, this loop slowed to a crawl. Corporations had all the money, but no one to sell to. They had automated the customer out of existence.</p>
            <p>Deflation set in. Prices dropped, but no one bought anything because they were waiting for prices to drop further, or simply had zero income.</p>
            <p><strong>Simulation:</strong> Velocity visualization. Watch the particles (transactions) slow down as Wealth Concentration hits 99%.</p>
        `,
        simId: "FREEZE",
        controls: `<label>Wealth Concentration <span id="val1">Low</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2060",
        title: "THE BIG CRASH",
        subtitle: "The Silent Depression",
        text: `
            <p><strong>This is the pivot point of history.</strong></p>
            <p>In 2060, the global supply chain halted. Warehouses were full of goods. Robots stood ready to build more. But the transaction layer ceased to exist. Unemployment hit 60%.</p>
            <p>It wasn't a stock market crash; it was a <strong>Demand Crash</strong>. The engine of capitalism (Labor for Income for Consumption) seized up completely.</p>
            <p><strong>Simulation:</strong> This is the Economy. Increase time. Watch Productivity (Blue) go vertical. Watch Wages (Green) hit zero. Watch the "Inventory" (Boxes) pile up until the system throws a critical error.</p>
        `,
        simId: "CRASH",
        controls: `<label>Timeline <span id="val1">2040</span></label><input type="range" min="2040" max="2070" value="2040" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2061",
        title: "The Failed Stimulus",
        subtitle: "Why printing money didn't work",
        text: `
            <p>Governments panicked. They tried the old playbook: Print money and lend it to people (Stimulus/Debt).</p>
            <p>It failed immediately. Why? Because you can only lend money to people who have jobs to pay it back. With no jobs, the credit was worthless.</p>
            <p>The money was printed, given out, spent once on food, and immediately vacuumed back up by the automated corporations, sitting in their accounts doing nothing. The loop was broken.</p>
            <p><strong>Simulation:</strong> Attempt to inject liquidity. Watch the water (money) pour in, but drain out instantly because there is no "Labor Floor" to hold it.</p>
        `,
        simId: "STIMULUS",
        controls: `<button class="nav-btn" style="width:100%; background:#ef4444" onclick="triggerStimulus()">INJECT $10 TRILLION</button>`
    },
    {
        year: "2062-2064",
        title: "The Realization",
        subtitle: "No Choice Left",
        text: `
            <p>Society faced a choice: Starve amidst abundance, or change the operating system.</p>
            <p>Economists realized that automation had turned labor into a legacy feature. We couldn't "create jobs" because humans were biologically obsolete for economic production.</p>
            <p>The realization was simple: <strong>Money must be decoupled from Labor.</strong> Money is just a ticket to allocate resources. If robots make the resources, we just need to distribute the tickets.</p>
            <p><strong>Simulation:</strong> The Scale. Balance "Production Capacity" against "Distribution Logic."</p>
        `,
        simId: "SCALE",
        controls: `<label>Ideological Shift <span id="val1">Traditional</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2065",
        title: "The Dividend Compact",
        subtitle: "Dividend Socialism",
        text: `
            <p>The treaty was signed. The "Automation Tax" was implemented. Every robot hour worked generated a micro-tax.</p>
            <p>This revenue was not filtered through bureaucracy; it was distributed instantly to every citizen as a <strong>Universal Dividend</strong>.</p>
            <p>This wasn't charity. It was the fuel injection required to make the machine run. The moment the dividend went live, the warehouses opened, goods moved, and the economy restarted.</p>
            <p><strong>Simulation:</strong> Connect the pipes. Open the "Dividend Valve" to close the loop between Producer and Consumer.</p>
        `,
        simId: "DIVIDEND",
        controls: `<label>Dividend Valve Flow <span id="val1">Closed</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2070",
        title: "The Purpose Crisis",
        subtitle: "What do we do now?",
        text: `
            <p>Survival was solved. But a new problem emerged: Meaning.</p>
            <p>For 5,000 years, humans defined themselves by their jobs. "I am a baker." "I am a coder." Without work, depression rates spiked.</p>
            <p>We had to culturally reinvent ourselves. We moved from a "Production Society" to an "Exploration Society." Art, philosophy, sport, and community became the new metrics of success.</p>
            <p><strong>Simulation:</strong> The Mental Health Grid. Allocate "Time" to Social, Creative, and Physical activities to stabilize the population mood.</p>
        `,
        simId: "PURPOSE",
        controls: `<label>Focus: Creativity <span id="val1">0%</span></label><input type="range" min="0" max="100" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2080",
        title: "The Legitimacy Economy",
        subtitle: "Status without Wealth",
        text: `
            <p>In 2080, being a "Billionaire" became meaningless. If everyone can afford a Ferrari (printed by robots), the Ferrari loses status.</p>
            <p>Status shifted to things robots couldn't produce: <strong>Legitimacy, Trust, and Attention.</strong></p>
            <p>The leaders of this era weren't the richest; they were the most trusted. Social capital replaced financial capital as the primary power structure.</p>
            <p><strong>Simulation:</strong> Hierarchy Visualization. Watch how the "Leader" node changes from the one with most Gold (Money) to the one with most Connections (Trust).</p>
        `,
        simId: "STATUS",
        controls: `<label>Metric: <span id="val1">Money</span></label><input type="range" min="0" max="1" step="1" value="0" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2090",
        title: "Allocation of the Scarce",
        subtitle: "Land and Reality",
        text: `
            <p>Robots could print goods, but they couldn't print Land. Who gets the beach house?</p>
            <p>We moved to "Access Rights." Instead of buying land forever, you gained time-limited leases based on lotteries and merit.</p>
            <p>This prevented a permanent aristocracy. It ensured that the "Prime Reality" circulated among the population rather than being hoarded.</p>
            <p><strong>Simulation:</strong> The Map. Toggle between "Market Allocation" (Static Ownership) and "Access Allocation" (Circulation).</p>
        `,
        simId: "LAND",
        controls: `<button class="nav-btn" onclick="updateParam('p1', 0)">Market Mode</button> <button class="nav-btn" onclick="updateParam('p1', 1)">Access Mode</button>`
    },
    {
        year: "2100",
        title: "The Guardrails",
        subtitle: "Containing the Infinite",
        text: `
            <p>AI Intelligence was now billions of times greater than human intelligence. The risk wasn't economic anymore; it was existential.</p>
            <p>Society built the "Great Guardrails." We used AI to police AI. Research was accelerated, but automated safety loops checked every discovery before implementation.</p>
            <p>We essentially built a nuclear reactor for intelligence, carefully managed to prevent a meltdown.</p>
            <p><strong>Simulation:</strong> The Reactor. Increase Research Speed, but keep Risk below the critical threshold using Safety Checks.</p>
        `,
        simId: "GUARDRAILS",
        controls: `<label>Research Speed <span id="val1">Safe</span></label><input type="range" min="0" max="100" value="20" oninput="updateParam('p1', this.value)">`
    },
    {
        year: "2150",
        title: "The Horizon",
        subtitle: "To the Stars",
        text: `
            <p>Here we are, in 2150.</p>
            <p>We have decoupled survival from labor. We have stabilized the social structure. We have unlimited intelligence and energy.</p>
            <p>The only frontier left is outwards. The surplus energy of humanity is now directed at Mars, Europa, and Alpha Centauri. We are no longer laborers; we are explorers.</p>
            <p><strong>Simulation:</strong> Launch the fleet.</p>
        `,
        simId: "SPACE",
        controls: `<button class="nav-btn" style="width:100%; background:var(--accent-cyan)" onclick="triggerLaunch()">INITIATE LAUNCH SEQUENCE</button>`
    }
];

/**
 * --- APP STATE & INIT ---
 */
let currentChapterIdx = 0;
let simParams = { p1: 0, p2: 0 };
let canvas, ctx;
let animationFrame;

// Canvas Helpers
function resizeCanvas() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
}

function init() {
    canvas = document.getElementById('simCanvas');
    ctx = canvas.getContext('2d');
    
    // Populate Sidebar
    const sidebar = document.getElementById('sidebar');
    chapters.forEach((chap, i) => {
        const div = document.createElement('div');
        div.className = `timeline-item ${i === 0 ? 'active' : ''}`;
        div.innerHTML = `<div class="t-year">${chap.year}</div><div class="t-title">${chap.title}</div>`;
        div.onclick = () => loadChapter(i);
        sidebar.appendChild(div);
    });

    window.addEventListener('resize', resizeCanvas);
    loadChapter(0);
}

/**
 * --- CORE LOGIC ---
 */
function loadChapter(index) {
    currentChapterIdx = index;
    simParams = { p1: 0, p2: 0 }; // Reset params
    
    // UI Updates
    const chap = chapters[index];
    const sidebarItems = document.querySelectorAll('.timeline-item');
    sidebarItems.forEach((item, i) => {
        item.className = `timeline-item ${i === index ? 'active' : ''}`;
        // Scroll to active
        if (i === index) item.scrollIntoView({ behavior: 'smooth', block: 'center' });
    });

    // Narrative Update
    const narrative = document.getElementById('narrativeContent');
    narrative.innerHTML = `
        <h2>${chap.year} // ${chap.subtitle}</h2>
        <h1>${chap.title}</h1>
        ${chap.text}
        <div style="margin-top:40px; display:flex; gap:10px;">
            <button class="nav-btn" onclick="prev()" ${index===0?'disabled':''}>&larr; Back</button>
            <button class="nav-btn" onclick="next()" ${index===chapters.length-1?'disabled':''}>Next Era &rarr;</button>
        </div>
    `;

    // Controls Update
    const controls = document.getElementById('simControls');
    controls.innerHTML = chap.controls;
    controls.style.opacity = chap.controls ? 1 : 0;
    controls.style.pointerEvents = chap.controls ? 'all' : 'none';

    // Reset Sim values based on defaults in HTML strings (parsing rough default)
    // Actually, the slider oninput handles the state update, we just need to reset visual state.
    const defaultInput = controls.querySelector('input');
    if(defaultInput) {
        simParams.p1 = parseFloat(defaultInput.value);
        updateParam('p1', simParams.p1); // Update label
    }

    // Start Animation Loop
    if (animationFrame) cancelAnimationFrame(animationFrame);
    resizeCanvas();
    renderLoop();
}

function updateParam(key, value) {
    simParams[key] = parseFloat(value);
    
    // Update label text dynamically if exists
    const labelSpan = document.getElementById('val1');
    if(labelSpan) {
        // Custom label logic based on current chapter
        const id = chapters[currentChapterIdx].simId;
        if (id === "CRASH") labelSpan.innerText = value;
        else labelSpan.innerText = value + "%";
    }
}

function next() { if(currentChapterIdx < chapters.length-1) loadChapter(currentChapterIdx+1); }
function prev() { if(currentChapterIdx > 0) loadChapter(currentChapterIdx-1); }

/**
 * --- VISUALIZATION ENGINE ---
 * A giant switch statement that draws the specific "Toy" for the era.
 */
let simState = {}; // Persist particles etc

function renderLoop() {
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);
    
    const id = chapters[currentChapterIdx].simId;
    const time = Date.now() * 0.001;

    switch (id) {
        case "SPARK": renderSpark(w, h, time); break;
        case "AGENTS": renderAgents(w, h, time); break;
        case "ROBOTICS": renderRobotics(w, h, time); break;
        case "BOOM": renderBoom(w, h, time); break;
        case "SQUEEZE": renderSqueeze(w, h, time); break;
        case "FREEZE": renderFreeze(w, h, time); break;
        case "CRASH": renderCrash(w, h, time); break;
        case "STIMULUS": renderStimulus(w, h, time); break;
        case "SCALE": renderScale(w, h, time); break;
        case "DIVIDEND": renderDividend(w, h, time); break;
        case "PURPOSE": renderPurpose(w, h, time); break;
        case "STATUS": renderStatus(w, h, time); break;
        case "LAND": renderLand(w, h, time); break;
        case "GUARDRAILS": renderGuardrails(w, h, time); break;
        case "SPACE": renderSpace(w, h, time); break;
    }

    animationFrame = requestAnimationFrame(renderLoop);
}

// --- INDIVIDUAL SIMULATIONS ---

function renderSpark(w, h, t) {
    const density = simParams.p1; 
    const count = Math.floor(density * 2);
    
    ctx.fillStyle = '#06b6d4';
    ctx.strokeStyle = 'rgba(6, 182, 212, 0.3)';
    
    // Draw Neural Nodes
    const nodes = [];
    for(let i=0; i<count; i++) {
        // Deterministic psuedo-random positions based on i and t
        const x = w/2 + Math.cos(i*13 + t*0.2) * (w/4 + Math.sin(t)*20);
        const y = h/2 + Math.sin(i*19 + t*0.3) * (h/4);
        nodes.push({x,y});
        
        ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
    }
    
    // Draw Connections
    ctx.lineWidth = 1;
    for(let i=0; i<nodes.length; i++) {
        for(let j=i+1; j<nodes.length; j++) {
            const dist = Math.hypot(nodes[i].x - nodes[j].x, nodes[i].y - nodes[j].y);
            if(dist < 100) {
                ctx.beginPath(); ctx.moveTo(nodes[i].x, nodes[i].y); ctx.lineTo(nodes[j].x, nodes[j].y); ctx.stroke();
            }
        }
    }
}

function renderAgents(w, h, t) {
    const aiLevel = simParams.p1 / 100; // 0 to 1
    
    // Queue Bar
    const barX = w * 0.2;
    const barW = w * 0.6;
    const taskCount = 10;
    
    for(let i=0; i<taskCount; i++) {
        const x = barX + (barW/taskCount)*i;
        const y = h/2;
        
        // Determine who solves the task
        // Lower index tasks are easier, automated first
        const isAutomated = (i / taskCount) < aiLevel;
        
        ctx.fillStyle = isAutomated ? '#06b6d4' : '#10b981';
        ctx.fillRect(x + 5, y - 20, (barW/taskCount)-10, 40);
        
        // Label
        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.fillText(isAutomated ? "AI" : "HUMAN", x + 10, y + 5);
    }
    
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '14px sans-serif';
    ctx.fillText(`White Collar Automation: ${Math.round(aiLevel*100)}%`, w/2, h/2 - 50);
}

function renderRobotics(w, h, t) {
    const skill = simParams.p1; // 0 to 100
    const speed = 0.5 + (skill/20);
    
    const cx = w/2;
    const cy = h * 0.7;
    
    // Target
    const tx = cx + Math.cos(t * speed) * 150;
    const ty = cy - 200 + Math.sin(t * speed * 1.3) * 50;
    
    // Draw Target
    ctx.fillStyle = '#ef4444';
    ctx.beginPath(); ctx.arc(tx, ty, 10, 0, Math.PI*2); ctx.fill();
    
    // Arm Segments (Inverse Kinematics approx)
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 10;
    ctx.lineCap = 'round';
    
    // Base
    ctx.beginPath(); ctx.moveTo(cx, cy); 
    
    // Jitter based on low skill
    const jitter = (100 - skill) * 0.5;
    const jx = (Math.random()-0.5) * jitter;
    const jy = (Math.random()-0.5) * jitter;
    
    ctx.lineTo(tx + jx, ty + jy);
    ctx.stroke();
    
    // Base Box
    ctx.fillStyle = '#333';
    ctx.fillRect(cx-20, cy, 40, 20);
    
    ctx.fillStyle = '#fff';
    ctx.fillText(`Precision: ${skill}%`, cx, cy + 40);
}

function renderBoom(w, h, t) {
    const auto = simParams.p1;
    
    // Grid
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(50, h-50); ctx.lineTo(w-50, h-50); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(50, h-50); ctx.lineTo(50, 50); ctx.stroke();
    
    // GDP Line (Yellow) - Exponential
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(50, h-50);
    const endX = 50 + (w-100) * (auto/100);
    
    for(let x=50; x<w-50; x+=10) {
        const progress = (x-50)/(w-100);
        // GDP goes up
        const y = (h-50) - (progress * progress * 200) - (progress * auto * 2);
        ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    // Wage Line (Green) - Flat/Dip
    ctx.strokeStyle = '#10b981';
    ctx.beginPath();
    ctx.moveTo(50, h-50);
    for(let x=50; x<w-50; x+=10) {
        const progress = (x-50)/(w-100);
        // Wages rise then plateau then dip
        let y = (h-50) - (progress * 100);
        if (progress > 0.6) y += (progress - 0.6) * 50 * (auto/50); // Dip logic
        ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    ctx.fillStyle = '#f59e0b'; ctx.fillText("GDP (Profits)", w-100, h/2);
    ctx.fillStyle = '#10b981'; ctx.fillText("Wages", w-100, h-80);
}

function renderSqueeze(w, h, t) {
    const pressure = simParams.p1;
    const cols = 10;
    const rows = 5;
    const gap = w / (cols + 2);
    
    for(let i=0; i<cols; i++) {
        for(let j=0; j<rows; j++) {
            const x = gap + i*gap;
            const y = 50 + j * 50;
            
            // Person Status
            // Higher pressure = more red people
            const threshold = (100 - pressure) / 100;
            // Pseudo random based on index
            const val = (Math.sin(i*j*12) + 1) / 2;
            
            const isSolvent = val < threshold;
            
            ctx.fillStyle = isSolvent ? '#10b981' : '#ef4444';
            ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI*2); ctx.fill();
            
            if (!isSolvent) {
                ctx.strokeStyle = '#ef4444';
                ctx.beginPath(); ctx.moveTo(x-5, y-5); ctx.lineTo(x+5, y+5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x+5, y-5); ctx.lineTo(x-5, y+5); ctx.stroke();
            }
        }
    }
    
    ctx.fillStyle = '#fff';
    ctx.fillText("Green: Solvent | Red: Insolvent", w/2, h-20);
}

function renderFreeze(w, h, t) {
    const concentration = simParams.p1; // 0 to 100
    // Speed of particles depends on concentration (Higher concentration = Slower velocity for most)
    
    const particleCount = 50;
    if(!simState.freeze) {
        simState.freeze = Array.from({length:50}, () => ({
            x: Math.random()*w, y: Math.random()*h, 
            vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5
        }));
    }
    
    const speedMod = Math.max(0.05, 1 - (concentration/100));
    
    simState.freeze.forEach(p => {
        p.x += p.vx * speedMod;
        p.y += p.vy * speedMod;
        
        if(p.x < 0 || p.x > w) p.vx *= -1;
        if(p.y < 0 || p.y > h) p.vy *= -1;
        
        ctx.fillStyle = '#10b981';
        ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
    });
    
    // The Hoard
    const r = (concentration/100) * 100;
    ctx.fillStyle = 'rgba(245, 158, 11, 0.3)';
    ctx.beginPath(); ctx.arc(w/2, h/2, r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.fillText("Stagnant Capital", w/2, h/2);
}

function renderCrash(w, h, t) {
    const year = simParams.p1; // 2040 - 2070
    const progress = (year - 2040) / 30;
    
    // Split screen: Left = Chart, Right = Warehouse
    
    // 1. CHART
    const cw = w/2;
    ctx.strokeStyle = '#333';
    ctx.strokeRect(10, 10, cw-20, h-20);
    
    // Productivity (Blue)
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(10, h-20);
    ctx.lineTo(10 + (cw-20)*progress, h-20 - (progress*progress*300));
    ctx.stroke();
    
    // Wages (Green)
    ctx.strokeStyle = '#10b981';
    ctx.beginPath(); ctx.moveTo(10, h-20);
    let wy = h-20 - (progress * 100);
    if (year > 2055) wy = h-20; // Crash to zero
    ctx.lineTo(10 + (cw-20)*progress, wy);
    ctx.stroke();
    
    // 2. WAREHOUSE (Right side)
    const wx = w/2 + 20;
    const ww = w/2 - 40;
    ctx.fillStyle = '#222';
    ctx.fillRect(wx, 10, ww, h-20);
    
    // Boxes piling up
    let boxCount = Math.floor(progress * 200);
    if (year > 2060) boxCount = 500; // Max out
    
    ctx.fillStyle = '#f59e0b';
    const boxSize = 10;
    for(let i=0; i<boxCount; i++) {
        const bx = wx + (i % Math.floor(ww/boxSize)) * boxSize;
        const by = (h-20) - Math.floor(i / Math.floor(ww/boxSize)) * boxSize - boxSize;
        if(by > 10) ctx.fillRect(bx, by, boxSize-1, boxSize-1);
    }
    
    if (year >= 2060) {
        ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
        ctx.font = '30px sans-serif';
        ctx.fillText("DEMAND COLLAPSE", w * 0.75, h/2);
    }
}

function renderStimulus(w, h, t) {
    // Bucket with a hole
    const bx = w/2 - 50;
    const by = h/2;
    const bw = 100;
    const bh = 100;
    
    // Bucket
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(bx, by+bh); ctx.lineTo(bx+bw, by+bh); ctx.lineTo(bx+bw, by); ctx.stroke();
    
    // Hole
    ctx.clearRect(bx+20, by+bh-2, 60, 10);
    
    // Water (Money)
    if(simState.stimulusActive) {
        simState.waterLevel = 100;
        simState.stimulusActive = false;
    }
    
    if(simState.waterLevel > 0) {
        simState.waterLevel -= 2;
        const level = simState.waterLevel;
        
        ctx.fillStyle = '#10b981';
        ctx.fillRect(bx+5, by+bh - level, bw-10, level);
        
        // Draining out
        ctx.fillStyle = '#10b981';
        ctx.fillRect(bx+30, by+bh+5, 40, h - (by+bh));
        
        ctx.fillStyle = '#fff';
        ctx.fillText("Leaking to Corporate Savings...", w/2, h-20);
    } else {
        ctx.fillStyle = '#555';
        ctx.fillText("No Liquidity Retention", w/2, h/2+50);
    }
}
// Trigger function for button
window.triggerStimulus = () => { simState.stimulusActive = true; }


function renderScale(w, h, t) {
    const shift = simParams.p1;
    
    const cx = w/2;
    const cy = h/2;
    
    // Scale Beam
    const angle = (shift - 50) * 0.01; // Tilt
    
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(-100, 0); ctx.lineTo(100, 0); ctx.stroke();
    
    // Plates
    ctx.fillStyle = '#ef4444'; // Starvation
    ctx.beginPath(); ctx.arc(-100, 0, 20, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.fillText("Collapse", -120, -30);

    ctx.fillStyle = '#10b981'; // UBI
    ctx.beginPath(); ctx.arc(100, 0, 20, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.fillText("Dividend", 80, -30);

    ctx.restore();
    
    // Triangle Base
    ctx.fillStyle = '#555';
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx-20, cy+50); ctx.lineTo(cx+20, cy+50); ctx.fill();
}

function renderDividend(w, h, t) {
    const flow = simParams.p1;
    
    // Robot Factory (Left)
    ctx.fillStyle = '#333';
    ctx.fillRect(50, h/2 - 40, 60, 80);
    ctx.fillStyle = '#06b6d4'; ctx.fillText("ROBOTS", 55, h/2+5);
    
    // People (Right)
    ctx.fillStyle = '#333';
    ctx.fillRect(w-110, h/2 - 40, 60, 80);
    ctx.fillStyle = '#10b981'; ctx.fillText("PEOPLE", w-100, h/2+5);
    
    // Top Pipe (Goods)
    ctx.strokeStyle = '#444'; ctx.lineWidth=8;
    ctx.beginPath(); ctx.moveTo(110, h/2-20); ctx.lineTo(w-110, h/2-20); ctx.stroke();
    
    // Bottom Pipe (Dividend Money)
    ctx.strokeStyle = flow > 0 ? '#10b981' : '#444';
    ctx.beginPath(); ctx.moveTo(w-110, h/2+20); ctx.lineTo(110, h/2+20); ctx.stroke();
    
    // Particles
    if(simState.frame === undefined) simState.frame = 0;
    simState.frame++;
    
    // Goods
    if(simState.frame % 10 === 0) {
        if(!simState.goods) simState.goods = [];
        simState.goods.push({x: 110, y: h/2-20});
    }
    if(simState.goods) {
        simState.goods.forEach((g,i) => {
            g.x += 2;
            ctx.fillStyle = '#f59e0b'; ctx.fillRect(g.x, g.y-4, 8, 8);
            // Jam if no flow
            if(g.x > w/2 && flow < 10) {
                g.x -= 2; ctx.fillStyle = '#ef4444';
            }
            if(g.x > w-110) simState.goods.splice(i,1);
        });
    }
    
    // Money
    if(flow > 0 && simState.frame % (110 - flow) === 0) {
        if(!simState.money) simState.money = [];
        simState.money.push({x: w-110, y: h/2+20});
    }
    if(simState.money) {
        simState.money.forEach((m,i) => {
            m.x -= 2;
            ctx.fillStyle = '#10b981'; ctx.beginPath(); ctx.arc(m.x, m.y, 4, 0, Math.PI*2); ctx.fill();
            if(m.x < 110) simState.money.splice(i,1);
        });
    }
}

function renderPurpose(w, h, t) {
    const focus = simParams.p1;
    // Pie Chart visualization
    const cx = w/2, cy = h/2;
    const r = 100;
    
    // Base (Work - shrinking)
    const workSlice = Math.max(0, 2 * Math.PI * (1 - focus/100));
    
    ctx.beginPath(); ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, 0, workSlice);
    ctx.fillStyle = '#555'; // Work (Gray)
    ctx.fill();
    
    // Creative (Growing)
    ctx.beginPath(); ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, workSlice, 2 * Math.PI);
    ctx.fillStyle = '#f59e0b'; // Creative (Gold)
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    ctx.fillText("Gray: Labor | Gold: Creation", cx - 60, h - 20);
}

function renderStatus(w, h, t) {
    const mode = simParams.p1; // 0 = Money, 1 = Trust
    
    const nodes = [
        {x: w/2, y: h/2 - 50, money: 100, trust: 20}, // Rich Guy
        {x: w/2 - 60, y: h/2 + 50, money: 10, trust: 90}, // Community Leader
        {x: w/2 + 60, y: h/2 + 50, money: 20, trust: 80}, // Artist
    ];
    
    nodes.forEach(n => {
        // Radius based on status metric
        const size = mode == 0 ? n.money/2 : n.trust/2;
        const color = mode == 0 ? '#f59e0b' : '#06b6d4';
        
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(n.x, n.y, size, 0, Math.PI*2); ctx.fill();
    });
    
    ctx.fillStyle = '#fff';
    if(mode == 0) ctx.fillText("Dominance: Wealth", w/2, 20);
    else ctx.fillText("Dominance: Legitimacy", w/2, 20);
}

function renderLand(w, h, t) {
    const mode = simParams.p1; // 0 Market, 1 Access
    
    // Grid of plots
    const plots = 5;
    const size = 40;
    const startX = w/2 - (plots*size)/2;
    
    for(let i=0; i<plots; i++) {
        const x = startX + i*size;
        const y = h/2 - 20;
        
        if(mode == 0) {
            // Market: Owned by one color permanently
            ctx.fillStyle = i < 2 ? '#f59e0b' : '#333'; // Rich own best spots
        } else {
            // Access: Colors cycle
            const cycle = Math.floor(t + i) % 3;
            const colors = ['#06b6d4', '#10b981', '#ef4444'];
            ctx.fillStyle = colors[cycle];
        }
        
        ctx.fillRect(x, y, size-2, size-2);
    }
    
    ctx.fillStyle = '#fff';
    ctx.fillText(mode == 0 ? "Permanent Ownership" : "Rotating Access", w/2, h/2 + 50);
}

function renderGuardrails(w, h, t) {
    const speed = simParams.p1;
    
    const cx = w/2, cy = h/2;
    
    // Core
    const risk = speed > 80 ? 10 : 2;
    const shakeX = (Math.random()-0.5) * risk;
    const shakeY = (Math.random()-0.5) * risk;
    
    ctx.fillStyle = speed > 80 ? '#ef4444' : '#06b6d4';
    ctx.beginPath(); ctx.arc(cx+shakeX, cy+shakeY, 30, 0, Math.PI*2); ctx.fill();
    
    // Rings (Guardrails)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx, cy, 50, 0, Math.PI*2); ctx.stroke();
    
    if(speed > 80) {
        ctx.fillStyle = '#ef4444';
        ctx.fillText("WARNING: CONTAINMENT BREACH", cx, cy+80);
    } else {
        ctx.fillStyle = '#10b981';
        ctx.fillText("Systems Stable", cx, cy+80);
    }
}

function renderSpace(w, h, t) {
    // Stars
    for(let i=0; i<50; i++) {
        const x = (i*37)%w;
        const y = (i*103)%h;
        ctx.fillStyle = '#fff';
        ctx.fillRect(x, y + (simState.launch ? t*100 : 0) % h, 1, 1);
    }
    
    // Ship
    const cx = w/2;
    const cy = simState.launch ? h/2 - t*50 : h - 50;
    
    if(cy > -50) {
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx-10, cy+20); ctx.lineTo(cx+10, cy+20); ctx.fill();
        
        // Flame
        if(simState.launch) {
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath(); ctx.moveTo(cx-5, cy+20); ctx.lineTo(cx, cy+40 + Math.random()*10); ctx.lineTo(cx+5, cy+20); ctx.fill();
        }
    } else {
        ctx.fillStyle = '#fff';
        ctx.font = '20px sans-serif';
        ctx.fillText("ARCHIVE END.", w/2, h/2);
    }
}
window.triggerLaunch = () => { simState.launch = true; }


// BOOT
init();

</script>
</body>
</html>
